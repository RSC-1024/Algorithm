汇总
●	🚩点击注册后可保存到自己账户下编辑
😊电脑: Ctrl + F / 右上方🔍搜索, 输入#Tag做分类检索 💯手机: 保存到自己账户后手机APP打开可以快速检索题目及课程编号 题目前的数字是LeetCode题目编号, 点击题目链接可进入题目 注: 不用买会员, 去这里领取就行https://share.mubu.com/doc/7h3sR4DfnXA
●	左老师笔记
●	学前必读
●	算法和数据结构课程全梳理
●	算法和数据结构新手班
●	算法和数据结构体系学习班
●	算法和数据结构大厂刷题班
●	每周有营养的大厂算法面试题(正在直播)
●	算法课笔记
●	阶乘计算
#新手班01 
●	前缀和数组
#新手班02 
●	调整数出现的概率从x调整为x^2
#新手班02 
●	概率生成数字问题
#新手班02 
●	01不等概率随机到01等概率随机
#新手班02 
●	有序数组中找到num
#二分法 #新手班03 
●	有序数组中找到＞=num最左的位置
#二分法 #新手班03
●	有序数组中找到＜=num最右的位置
#二分法 #新手班03 
●	用单链表结构实现队列跟栈结构
#链表 #新手班04
●	用双链表实现双端队列
#链表 #新手班04 
●	单链表和双链表如何反转
#链表 #新手班04 
●	用单链表结构实现队列跟栈结构
#链表 #新手班04 
●	用双链表实现双端队列
#链表 #新手班04 
●	25.K个节点的组内逆序调整
#链表 #新手班04 #Hard #LeetCode 
●	2.两个链表相加
#链表 #新手班04 #Medium #LeetCode
●	21.两个有序链表的合并
#链表 #新手班04 #Easy #LeetCode
●	Java中位图的实现
#位图 #新手班05
●	用位运算实现加减乘除
#位图 #新手班05
●	29.两数相除
 #Medium
●	23.合并多个有序链表
#链表 #新手班06  #Hard #LeetCode
●	100.判断两颗树是否结构相同
#二叉树 #新手班06 #Easy #LeetCode
●	101.判断一棵树是否是镜面树
#二叉树 #新手班06  #Easy #LeetCode
●	104.返回一棵树的最大深度
#二叉树 #新手班06  #Easy #LeetCode
●	105.用先序数组和中序数组重建一棵树
#二叉树 #新手班06  #Medium #LeetCode
●	Java中的Stack结构
#二叉树 #新手班07
●	107.二叉树按层遍历并收集节点
#二叉树 #新手班07 #Easy #LeetCode
●	110.判断是否是平衡搜索二叉树
#二叉树 #新手班07 #Easy #LeetCode
●	112.能否组成路径和
#二叉树 #新手班07 #Easy #LeetCode
●	113.收集达标路径和
#二叉树 #新手班07 #Medium #LeetCode
●	选择排序
#排序  #体系班01 #新手班01
●	冒泡排序
#排序  #体系班01 #新手班01
●	插入排序
#排序  #体系班01 #新手班01 
●	在一个有序数组中，找某个数是否存在 
#二分法  #体系班01 #新手班03 
●	在一个有序数组中，找大于等于某个数最左侧的位置
 #二分法  #体系班01  #新手班03
●	在一个有序数组中，找小于等于某个数最右侧的位置
 #二分法  #体系班01 #新手班03
●	局部最小值问题
#二分法  #体系班01 #新手班03
●	在一个无序数组中, 值有可能正, 负, 或者零, 数组中任由两个相邻的数一定不相等.定义局部最小: 1.长度为1，arr[0]就是局部最小； 2.数组的开头，如果arr[0] < arr[1] ，arr[0]被定义为局部最小。  3.数组的结尾，如果arr[N-1] < arr[N-2] ，arr[N-1]被定义为局部最小。  任何一个中间位置i, 即数组下标1~N-2之间, 必须满足arr[i-1] < arr[i] <arr[i+1] ,叫找到一个局部最小。 请找到任意一个局部最小并返回。
●	如何不用额外变量交换两个数
#异或运算  #体系班02 
●	一个数组中出现了奇数次的数
#异或运算  #体系班02 
●	提取整数最右侧的1
#异或运算  #体系班02 
●	一个数组中出现奇数次的两个数
#异或运算  #体系班02 
●	一个数组中有一种数出现K次，其他数都出现了M次
#异或运算  #体系班02 
●	一个数组中有一种数出现K次，其他数都出现了M次，M > 1,  K < M 找到，出现了K次的数， 要求，额外空间复杂度O(1)，时间复杂度O(N)
●	单链表和双链表如何反转
#链表  #体系班03
●	把链表中的给定值都删除
#链表  #体系班03 
●	双向链表实现栈和队列
#链表  #体系班03 
●	数组实现栈和队列
#链表  #体系班03 
●	155.实现最小栈
#栈和队列 #体系班03 #LeetCode #Easy 
●	如何用栈结构实现队列结构
#栈和队列 #体系班03 
●	如何用队列结构实现栈结构
#栈和队列 #体系班03 
●	用递归方法求数组中的最大值
#递归  #体系班03
●	归并排序
#排序  #体系班04
●	求数组小和 
#归并排序  #体系班04
●	在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。   例子： [1,3,4,2,5]    1左边比1小的数：没有   3左边比3小的数：1   4左边比4小的数：1、3   2左边比2小的数：1   5左边比5小的数：1、3、4、 2   所以数组的小和为1+1+3+1+1+3+4+2=16
●	求数组中的逆序对数量
#归并排序  #体系班04
●	求数组中的大两倍数对数量
#归并排序  #体系班04
●	327. 区间和达标的子数组数量
#归并排序  #体系班05 #Hard #LeetCode
●	给定一个数组arr，和两个整数a和b（a<=b）求arr中有多少个子数组，累加和在[a,b]这个范围上，返回达标的子数组数量 给定一个数组arr，两个整数lower和upper， 返回arr中有多少个子数组的累加和在[lower,upper]范围上
●	快速排序
#排序   #体系班05
●	手写堆
#加强堆   #体系班06
●	堆排序
#排序   #体系班06
●	相对几乎有序数组排序
#大根堆小根堆   #体系班06
●	已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。请选择一个合适的排序策略，对这个数组进行排序。
●	最大线段重合问题
#大根堆小根堆   #体系班07
●	给定很多线段，每个线段都有两个数组[start, end]，表示线段开始位置和结束位置，左右都是闭区间 规定：   1）线段的开始和结束位置一定都是整数值   2）线段重合区域的长度必须>=1   返回线段最多重合区域中，包含了几条线段
●	给购买次数最多的前K名用户颁奖
#加强堆   #体系班07
●	固定数组实现前缀树
#前缀树  #体系班08 #Trie 
●	哈希表实现前缀树
#前缀树  #体系班08 #Trie 
●	计数排序
#排序 #体系班08
●	基数排序代码
#排序 #体系班08
●	在整型数组中把奇数放在左边偶数放在右边且保持稳定性
#贱人题 #体系班09
●	在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。时间复杂度做到O(N)，额外空间复杂度做到O(1)
●	判断链表是否为回文结构
#链表 #体系班09
●	给定一个单链表的头节点head，请判断该链表是否为回文结构。  1）堆栈方法特别简单（笔试用） 2）改原链表的方法就需要注意边界了（面试用）
●	将单向链表按某值划分成左边小、中间相等、右边大的形式
#链表 #体系班09 
●	1）把链表放入数组里，在数组上做partition（笔试用） 2）分成小、中、大三部分，再把各个部分之间串起来（面试用）
●	链表改序问题
#链表 #体系班09 
●	138.深度复制带有rand指针的链表
#链表 #体系班09  #LeetCode   #Medium 
●	给你链表头结点H, 如果链表长度为偶数, 比如长度为8, 规定前4个节点编号 L1, L2, L3, L4, 后四个节点编号R1, R2, R3, R4, 请把把链表调整为:L1->R4->L2->R3->L3->R2->L4->R1的顺序
●	两个可能有环的单链表相交的第一个节点
#链表 #体系班10
●	给定两个可能有环也可能无环的单链表，头节点head1和head2。 请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null   【要求】   如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。
●	二叉树某一节点X祖先节点的交集
#二叉树 #体系班10
●	某个节点X ,有一个先序遍历的顺序, X是二叉树中某一个节点, 我得到了整棵树的先序遍历, 我也知道这颗树的后序遍历,  则有结论:X先序遍历之前的节点定义为集合A, X后序遍历之后的节点定义为集合B, 则 A∩B得到的解释是且仅是X的祖先节点
 
●	非递归方式实现二叉树的三序遍历
#二叉树 #体系班10
●	不给头结点,删除单链表上的节点
#链表 #体系班11
●	实现二叉树的按层遍历
#二叉树 #体系班11 #高频
●	二叉树的序列化和反序列化
#二叉树 #体系班11 #高频
●	431. 将 N 叉树编码为二叉树
#二叉树 #体系班11 #Hard  #LeetCode
●	设计一个算法，可以将 N 叉树编码为二叉树，并能将该二叉树解码为原 N 叉树。一个 N 叉树是指每个节点都有不超过 N 个孩子节点的有根树。类似地，一个二叉树是指每个节点都有不超过 2 个孩子节点的有根树。你的编码 / 解码的算法的实现没有限制，你只需要保证一个 N 叉树可以编码为二叉树且该二叉树可以解码回原始 N 叉树即可。  例如，你可以将下面的 3-叉 树以该种方式编码：
 
●	注意，上面的方法仅仅是一个例子，可能可行也可能不可行。你没有必要遵循这种形式转化，你可以自己创造和实现不同的方法。 注意： N 的范围在 [1, 1000] 不要使用类成员 / 全局变量 / 静态变量来存储状态。你的编码和解码算法应是无状态的。
●	如何设计一个打印整棵树的打印函数
#二叉树 #体系班11
●	求二叉树最宽的层有多少个节点
#二叉树 #体系班11
●	二叉树中指定节点的后继节点
#二叉树 #体系班11
●	从上到下打印对折纸条所有折痕的方向
#二叉树 #体系班11
●	请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。  如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。  给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。  例如:N=1时，打印: down N=2时，打印: down down up
●	判断二叉树是不是平衡二叉树
#二叉树 #树型DP #体系班12  #二叉树的递归套路
●	判断二叉树是不是满二叉树
#二叉树 #树型DP #体系班12  #二叉树的递归套路
●	判断二叉树是不是搜索二叉树
#二叉树 #树型DP #体系班12  #二叉树的递归套路
●	二叉树中最大的二叉搜索子树的大小
#二叉树 #树型DP #体系班12  #二叉树的递归套路
●	判断二叉树是不是完全二叉树
#二叉树 #树型DP #体系班13  #二叉树的递归套路
●	二叉树中最大的二叉搜索子树的头节点
#二叉树 #树型DP #体系班13  #二叉树的递归套路
●	二叉树上两个节点的最低公共祖先
#二叉树 #树型DP #体系班13  #二叉树的递归套路 #最近公共祖先
●	求二叉树两个节点的最大距离
#二叉树 #树型DP #二叉树的递归套路 #体系班13
●	派对的最大快乐值
#二叉树 #树型DP #二叉树的递归套路 #体系班13
●	员工信息的定义如下: ``` class Employee {     public int happy; // 这名员工可以带来的快乐值     List<Employee> subordinates; // 这名员工有哪些直接下级 } ```  公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。 树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。  叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。 这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则： 1.如果某个员工来了，那么这个员工的所有直接下级都不能来 2.派对的整体快乐值是所有到场员工快乐值的累加 3.你的目标是让派对的整体快乐值尽量大 给定一棵多叉树的头节点boss，请返回派对的最大快乐值。
●	字符串组成的数组拼接后字典序最小的结果
#字典序 #贪心 #体系班13
●	给定一个由字符串组成的数组strs，必须把所有的字符串拼接起来，返回所有可能的拼接结果中，字典序最小的结果
●	会议室能容纳的最多宣讲场次
#贪心 #体系班14
●	一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间 你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。 返回最多的宣讲场次。
●	金条分割的最小代价
#贪心 #体系班14 #霍夫曼树 #哈夫曼树
●	一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管怎么切，都要花费20个铜板。 一群人想整分整块金条，怎么分最省铜板?  例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。 如果先把长度60的金条分成10和50，花费60; 再把长度50的金条分成20和30，花费50;一共花费110铜板。 但如果先把长度60的金条分成30和30，花费60;再把长度30金条分成10和20， 花费30;一共花费90铜板。 输入一个数组，返回分割的最小代价。
●	海盗分金
●	点亮str中所有需要点亮的位置至少需要几盏灯
#贪心 #体系班14
●	给定一个字符串str，只由‘X’和‘.’两种字符构成。‘X’表示墙，不能放灯，也不需要点亮 ‘.’表示居民点，可以放灯，需要点亮 如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮 返回如果点亮str中所有需要点亮的位置，至少需要几盏灯
●	做项目获得的最大钱数
#贪心 #体系班14
●	547. 朋友圈  岛屿数量|岛问题
 #Medium  #并查集 #体系班15 #LeetCode
●	305. 岛屿数量 II
 #Hard #并查集 #体系班15 #LeetCode
●	假设你设计一个游戏，用一个 m 行 n 列的 2D 网格来存储你的游戏地图。起始的时候，每个格子的地形都被默认标记为「水」。我们可以通过使用 addLand 进行操作，将位置 (row, col) 的「水」变成「陆地」。 你将会被给定一个列表，来记录所有需要被操作的位置，然后你需要返回计算出来 每次 addLand 操作后岛屿的数量。 注意：一个岛的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。你可以假设地图网格的四边均被无边无际的「水」所包围。 请仔细阅读下方示例与解析，更加深入了解岛屿的判定。 示例: ```text 输入: m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]] 输出: [1,1,2,3] ``` 解析: 起初，二维网格 grid 被全部注入「水」。（0 代表「水」，1 代表「陆地」） ```text 0 0 0 0 0 0 0 0 0 ``` 操作 #1：addLand(0, 0) 将 grid[0][0] 的水变为陆地。 ```text 1 0 0 0 0 0   Number of islands = 1 0 0 0 ``` 操作 #2：addLand(0, 1) 将 grid[0][1] 的水变为陆地。 ```text 1 1 0 0 0 0   岛屿的数量为 1 0 0 0 ``` 操作 #3：addLand(1, 2) 将 grid[1][2] 的水变为陆地。 ```text 1 1 0 0 0 1   岛屿的数量为 2 0 0 0 ``` 操作 #4：addLand(2, 1) 将 grid[2][1] 的水变为陆地。 ```text 1 1 0 0 0 1   岛屿的数量为 3 0 1 0 ``` 拓展：   你是否能在 O(k log mn) 的时间复杂度程度内完成每次的计算？（k 表示 positions 的长度）
●	岛问题并行算法
 #并查集 #体系班15
●	图的拓扑排序算法
#图 #图论 #拓扑排序 #体系班16
●	1）在图中找到所有入度为0的点输出 2）把所有入度为0的点在图中删掉，继续找入度为0的点输出，周而复始   3）图的所有点都被删除后，依次输出的顺序就是拓扑排序   要求：有向图且其中没有环 应用：事件安排、编译顺序
●	127.拓扑排序
 #Medium  #LintCode
●	给定一个有向图，图节点的拓扑排序定义如下:   对于图中的每一条有向边 A -> B , 在拓扑排序中A一定在B之前.   拓扑排序中的第一个节点可以是图中的任何一个没有其他节点指向它的节点.   针对给定的有向图找到任意一种拓扑排序的顺序.   你可以假设图中至少存在一种拓扑排序   例如以下的图: ![[Pasted image 20201225013639.png]] 拓扑排序可以为: ``` [0, 1, 2, 3, 4, 5] [0, 2, 3, 1, 5, 4] ``` 挑战 能否分别用BFS和DFS完成？
●	最小生成树算法之Kruskal
#图 #图论  #体系班16
●	最小生成树算法之Prim
#图 #图论  #体系班16
●	Dijkstra算法
#图 #图论  #体系班16 #单源最短路径问题 #Dijkstra
●	打印n层汉诺塔从最左边移动到最右边的全部过程
#递归 #体系班17
●	打印一个字符串的全部子序列
#递归 #体系班17
●	打印一个字符串的全部子序列，要求不要出现重复字面值的子序列
#递归 #体系班17
●	打印一个字符串的全部排列
#递归 #体系班17
●	打印一个字符串的全部排列，要求不要出现重复的排列
#递归 #体系班17
●	递归逆序一个栈
#递归 #体系班17
●	机器人必须走 K 步，最终能来到P位置的方法有多少种
#递归 #动态规划 #DP #体系班18  #范围上的尝试模型
●	假设有排成一行的N个位置，记为1~N，N 一定大于或等于 2开始时机器人在其中的M位置上(M 一定是 1~N 中的一个) 如果机器人来到1位置，那么下一步只能往右来到2位置； 如果机器人来到N位置，那么下一步只能往左来到 N-1 位置； 如果机器人来到中间位置，那么下一步可以往左走或者往右走； 规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种 给定四个参数 N、M、K、P，返回方法数。
●	A,B玩家从左右两边拿纸牌,返回最后获胜者的分数
#递归 #动态规划 #DP #体系班18  #范围上的尝试模型
●	给定一个整型数组arr，代表数值不同的纸牌排成一条线，   玩家A和玩家B依次拿走每张纸牌，    规定玩家A先拿，玩家B后拿，    但是每个玩家每次只能拿走最左或最右的纸牌，    玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数
●	背包能装下最多的价值
#递归 #动态规划 #DP #体系班19  #从左往右的尝试模型
●	给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表 i号物品的重量和价值。 给定一个正数bag，表示一个载重bag的袋子， 你装的物品不能超过这个重量。 返回你能装下最多的价值是多少?
●	数字转化为字符串的结果数
#递归 #动态规划 #DP #体系班19  #从左往右的尝试模型
●	规定1和A对应、2和B对应、3和C对应...  那么一个数字字符串比如"111”就可以转化为:   "AAA"、"KA"和"AK"   给定一个只有数字字符组成的字符串str，返回有多少种转化结果
●	691. 多少张贴纸可以贴出给定字符串|贴纸拼词
#递归 #动态规划 #DP #体系班19 #不需要搞成严格表结构的动态规划 #Hard #LeetCode
●	给定一个字符串str，给定一个字符串类型的数组arr。 arr里的每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来。 返回需要至少多少张贴纸可以完成这个任务。 例子：str= "babac"，arr = {"ba","c","abcd"} 至少需要两张贴纸"ba"和"abcd"，因为使用这两张贴纸，把每一个字符单独剪开，含有2个a、2个b、1个c。是可以拼出str的。所以返回2。
●	两个字符串的最长公共子序列
#递归 #动态规划 #DP #体系班19 #一个样本做行一个样本做列
●	516. 最长回文子序列
#递归 #动态规划 #DP #体系班20 #一个样本做行一个样本做列 #范围上的尝试模型  #Medium #LeetCode
●	给定一个字符串str，求最长回文子序列长度
●	象棋问题-马只走K步跳到指定位置的方法数
#递归 #动态规划 #DP #体系班20 #样本对应模型
●	请同学们自行搜索或者想象一个象棋的棋盘，然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置 那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域 给你三个 参数 x，y，k 返回“马”从(0,0)位置出发，必须走k步 最后落在(x,y)上的方法数有多少种?
●	喝咖啡洗咖啡杯问题
#递归 #动态规划 #DP #体系班20 #寻找业务限制的尝试模型 #京东
●	给定一个数组arr，arr[i]代表第i号咖啡机泡一杯咖啡的时间 给定一个正数N，表示N个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡 只有一台洗咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯 每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发 假设所有人拿到咖啡之后立刻喝干净， 返回从开始等到所有咖啡机变干净的最短时间 三个参数：int[] arr、int N，int a、int b
●	64.二维数组最小路径和
#递归 #动态规划 #DP #体系班21 #空间压缩技巧
●	货币数组组成面值的方法数-同值认为不同
#递归 #动态规划 #DP #体系班21 #从左往右的尝试模型  #硬币找零
●	arr是货币数组，其中的值都是正数。再给定一个正数aim。 每个值都认为是一张货币， 即便是值相同的货币也认为每一张都是不同的， 返回组成aim的方法数 例如：arr = {1,1,1}，aim = 2 第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2 一共就3种方法，所以返回3
●	面值数组组成面值的方法数-张数不限
#递归 #动态规划 #DP #体系班21 #从左往右的尝试模型  #硬币找零
●	给定数组arr，arr中所有的值都为正数且不重复 每个值代表一种面值的货币，每种面值的货币可以使用任意张 再给定一个整数 aim，代表要找的钱数 求组成 aim 的方法数
●	货币数组组成面值的方法数-同值无差别(张数限定)
#递归 #动态规划 #DP #体系班21 #斜率优化 #从左往右的尝试模型  #硬币找零
●	arr是货币数组，其中的值都是正数。再给定一个正数aim。 每个值都认为是一张货币， 认为值相同的货币没有任何不同， 返回组成aim的方法数 例如：arr = {1,2,1,1,2,1,2}，aim = 4 方法：1+1+1+1、1+1+2、2+2 一共就3种方法，所以返回3
●	Bob生还的概率
#递归 #动态规划 #DP #体系班21 #斜率优化 #一个样本做行一个样本做列
●	给定5个参数，N，M，row，col，k表示在N * M的区域上，醉汉Bob初始在(row,col)位置 Bob一共要迈出k步，且每步都会等概率向上下左右四个方向走一个单位 任何时候Bob只要离开N* M的区域，就直接死亡 返回k步之后，Bob还在N * M的区域的概率
●	英雄砍死怪兽的概率
#递归 #动态规划 #DP #体系班22 #斜率优化 #一个样本做行一个样本做列
●	给定3个参数，N，M，K  怪兽有N滴血，等着英雄来砍自己   英雄每一次打击，都会让怪兽流失[0-M]的血量   到底流失多少?每一次在[0~M]上等概率的获得一个值   求K次打击之后，英雄把怪兽砍死的概率
●	面值数组组成面值的最少货币数
#递归 #动态规划 #DP #体系班22 #斜率优化 #从左往右的尝试模型  #硬币找零
●	arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。每个值都认为是一种面值，且认为张数是无限的。 返回组成aim的最少货币数
●	给定一个正整数n, 求裂开的方法数
#递归 #动态规划 #DP #体系班22 #斜率优化  #从左往右的尝试模型  #硬币找零
●	正数数组分割为累加和接近的两个集合
#递归 #动态规划 #DP #体系班23
●	给定一个正数数组arr，请把arr中所有的数分成两个集合，尽量让两个集合的累加和接近 返回： 最接近的情况下，较小集合的累加和
●	正数数组分割为个数跟累加和接近的两个集合
#递归 #动态规划 #DP #体系班23
●	给定一个正数数组arr，请把arr中所有的数分成两个集合   如果arr长度为偶数，两个集合包含数的个数要一样多    如果arr长度为奇数，两个集合包含数的个数必须只差一个    请尽量让两个集合的累加和接近    返回:      最接近的情况下，较小集合的累加和    （较大集合的累加和一定是所有数累加和减去较小集合的累加和）
●	51. N皇后问题
#递归 #动态规划 #DP #体系班23 #范围上尝试的模型 #Hard #LeetCode #位图
●	N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列， 也不在同一条斜线上 给定一个整数n，返回n皇后的摆法有多少种。n=1，返回1 n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0 n=8，返回92
●	239. 滑动窗口最大值
#窗口内最大值或最小值的更新结构 #体系班24 #滑动窗口  #Hard  #LeetCode
●	整形数组中子数组最大值减最小值达标的子数组个数
#窗口内最大值或最小值的更新结构 #体系班24 #滑动窗口
●	给定一个整型数组arr，和一个整数num 某个arr中的子数组sub，如果想达标，必须满足： sub中最大值 – sub中最小值 <= num， 返回arr中达标子数组的数量
●	加油站的良好出发点问题
#窗口内最大值或最小值的更新结构 #体系班24 #滑动窗口
●	N个加油站组成一个环形，给定两个长度都是N的非负数组 oil和dis(N>1)，oil[i]代表 第i个加油站存的油可以跑多少千米，dis[i]代表第i个加油站到环中下一个加油站相隔 多少千米。  假设你有一辆油箱足够大的车，初始时车里没有油。如果车从第i个加油站出发，最终 可以回到这个加油站，那么第i个加油站就算良好出发点，否则就不算。  请返回长度为N的boolean型数组res，res[i]代表第 i 个加油站是不是良好出发点。
●	简化版: 134.加油站
 #Hard
●	货币数组组成面值的最少货币数
#窗口内最大值或最小值的更新结构 #体系班24 #滑动窗口 #斜率优化
●	arr是货币数组，其中的值都是正数。再给定一个正数aim。每个值都认为是一张货币， 返回组成aim的最少货币数 注意： 因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了
●	单调栈
#单调栈 #体系班25
●	正数数组中子数组累加和乘最小值的最大值
#单调栈 #体系班25
●	给定一个只包含正数的数组arr，arr中任何一个子数组sub，一定都可以算出(sub累加和 )* (sub中的最小值)是什么， 那么所有子数组中，这个值最大是多少？
●	84. 柱状图中最大的矩形
#单调栈 #体系班25 #Hard #LeetCode
●	给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。
●	86. 全是1的最大子矩形面积|最大矩形
#单调栈 #体系班25 #Hard #LeetCode
●	给定一个二维数组matrix, 其中的值不是0就是1, 返回全部由1组成的最大子矩形,  内部有多少个1给定一个二维数组matrix，其中的值不是0就是1，其中，内部全是1的所有子矩阵中，含有最多1的子矩阵中，含有几个1？ 给定一个无序矩阵，只包含0 和1 两种元素，求只包含1的最大子矩阵的大小。 --- 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例 1： ```text 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],  ["1","1","1","1","1"],["1","0","0","1","0"]] 输出：6 解释：最大矩形如上图所示。 示例 2： 输入：matrix = [] 输出：0 示例 3： 输入：matrix = [["0"]] 输出：0 示例 4： 输入：matrix = [["1"]] 输出：1 示例 5： 输入：matrix = [["0","0"]] 输出：0   提示： rows == matrix.length cols == matrix[0].length 0 <= row, cols <= 200 matrix[i][j] 为 '0' 或 '1' ```
 
●	1504. 全是1的子矩阵数量|统计全 1 子矩形
#单调栈 #体系班25  #Medium #LeetCode
●	907. 子数组最小值的累加和
#单调栈 #体系班26  #Medium #LeetCode
●	给定一个数组arr，返回所有子数组最小值的累加和
●	斐波那契数列矩阵乘法方式的实现
#斐波那契数列  #体系班26
●	一个人迈上N级台阶的方法数
#斐波那契数列  #体系班26
●	一个人可以一次往上迈1个台阶，也可以迈2个台阶 返回这个人迈上N级台阶的方法数
●	母牛生小牛, N年后牛的数量
#斐波那契数列  #体系班26
●	第一年农场有1只成熟的母牛A，往后的每年： 1）每一只成熟的母牛都会生一只母牛 2）每一只新出生的母牛都在出生的第三年成熟 3）每一只母牛永远不会死 返回N年后牛的数量
●	由0和1两种字符构成的达标字符串
#斐波那契数列  #体系班26
●	给定一个数N，想象只由0和1两种字符，组成的所有长度为N的字符串如果某个字符串,任何0字符的左边都有1紧挨着,认为这个字符串达标 返回有多少达标的字符串
●	KMP算法
#体系班27
●	Manacher算法
 #体系班28  #Manacher算法
●	字符串变为回文需要添加的最少字符
 #体系班28  #Manacher算法
●	给定一个字符串, 让它整体变回文字符串, 只能在后面添加字符, 最短加多少个
●	判断两个字符串是否互为旋转词|旋转字符串
 #体系班28  #Manacher算法
●	判断str1和str2是否是旋转字符串
●	两棵二叉树是否有一致结构的子树
 #体系班28  #Manacher算法
●	给定两棵二叉树的头节点head1和head2 想知道head1中是否有某个子树的结构和head2完全一样
●	在无序数组中求第K小的数
 #体系班29 #bfprt #改写快排
●	1）改写快排的方法   2）bfprt算法
●	无序数组中求Top K
 #体系班29 #bfprt #改写快排
●	给定一个无序数组arr中，长度为N，给定一个正数k，返回top k个最大的数不同时间复杂度三个方法： 1）O(N* logN) 2）O(N + K* logN) 3）O(n + k* logk)
●	机器所有吐出的球都等概率放进袋子里
 #体系班29 #蓄水池抽样
●	服务器今天登录所有用户抽出100个幸运观众
 #体系班29 #蓄水池抽样
●	Morris遍历
 #体系班30 #Morris遍历
●	Morris实现前序遍历
 #体系班30 #Morris遍历
●	Morris实现中序遍历
 #体系班30 #Morris遍历
●	Morris实现后序遍历 : 比较难
 #体系班30 #Morris遍历
●	二叉树的最小深度  Morris遍历实现
 #体系班30 #Morris遍历
●	给定一棵二叉树的头节点head, 求以head为头的树中，最小深度是多少？二叉树只有到了叶子节点才有高度, 所有叶子节点中, 哪一个是距离头结点最短的, 把这个距离返回
●	判断二叉树是不是平衡二叉树  Morris遍历实现
 #体系班30 #Morris遍历
●	给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树
●	线段树实例一
 #体系班31 #线段树
●	给定一个数组arr，用户希望你实现如下三个方法1） void add(int L, int R, int V) :  让数组arr[L…R]上每个数都加上V 2）void update(int L, int R, int V) :  让数组arr[L…R]上每个数都变成V 3）int sum(int L, int R) :让返回arr[L…R]这个范围整体的累加和 怎么让这三个方法，时间复杂度都是O(logN)
●	方块掉落之后的最大高度|线段树实例二
 #体系班31 #线段树
●	想象一下标准的俄罗斯方块游戏，X轴是积木最终下落到底的轴线  下面是这个游戏的简化版：   1）只会下落正方形积木   2）[a,b] -> 代表一个边长为b的正方形积木，积木左边缘沿着X = a这条线从上方掉落   3）认为整个X轴都可能接住积木，也就是说简化版游戏是没有整体的左右边界的   4）没有整体的左右边界，所以简化版游戏不会消除积木，因为不会有哪一层被填满。   给定一个N* 2的二维数组matrix，可以代表N个积木依次掉落，返回每一次掉落之后的最大高度
 
●	699. 掉落的方块
#线段树 #LeetCode  #Hard
●	IndexTree
 #体系班32
●	308.二维区域和检索 - 可变
 #体系班32 #Hard  #LeetCode
●	给你一个 2D 矩阵 matrix，请计算出从左上角 (row1, col1) 到右下角 (row2, col2) 组成的矩形中所有元素的和。 上述粉色矩形框内的，该矩形由左上角 (row1, col1) = (2, 1) 和右下角 (row2, col2) = (4, 3) 确定。其中，所包括的元素总和 sum = 8。 示例： ``` 给定 matrix = [   [3, 0, 1, 4, 2],   [5, 6, 3, 2, 1],   [1, 2, 0, 1, 5],   [4, 1, 0, 1, 7],   [1, 0, 3, 0, 5] ] sumRegion(2, 1, 4, 3) -> 8 update(3, 2, 2) sumRegion(2, 1, 4, 3) -> 10 ``` 注意: 矩阵 matrix 的值只能通过 update 函数来进行修改 你可以默认 update 函数和 sumRegion 函数的调用次数是均匀分布的 你可以默认 row1 ≤ row2，col1 ≤ col2
 
●	AC自动机
 #体系班32
●	布隆过滤器
 #体系班33
●	一致性哈希
 #体系班33
●	1G内存40亿个无符号整数的文件中找到出现次数最多的数
 #体系班34 #资源限制类题目
●	32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件， 可以使用最多1GB的内存，怎么找到出现次数最多的数？
●	内存限制为 10MB, 但是只用找到一个没出现过的数
 #体系班34 #资源限制类题目
●	100亿个URL的大文件中找出其中所有重复的URL
 #体系班34 #资源限制类题目
●	40亿个无符号整数找出所有出现了两次的数
 #体系班34 #资源限制类题目
●	32位无符号整数的范围是0~4294967295， 现在有40亿个无符号整数， 可以使用最多1GB的内存， 找出所有出现了两次的数。
●	40亿个无符号整数的中位数
 #体系班34 #资源限制类题目
●	32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数 可以使用最多10MB的内存，怎么找到这40亿个整数的中位数？
●	有一个10G大小的文件中的数字排序
 #体系班34 #资源限制类题目
●	32位无符号整数的范围是0~4294967295， 有一个10G大小的文件，每一行都装着这种类型的数字， 整个文件是无序的，给你5G的内存空间， 请你输出一个10大小的文件，就是原文件所有数字排序的结果
●	求出每天热门Top100词汇
 #体系班34 #资源限制类题目
●	搜索二叉树
 #体系班35 #有序表 #BST
●	AVL树
 #体系班35 #有序表
●	SB树（size-balance-tree）
 #体系班35 #有序表
●	跳表（skiplist）
 #体系班35 #有序表
●	327.区间和达标的子数组数量
 #体系班37 #有序表 #Hard #LeetCode
●	给定一个数组arr，和两个整数a和b（a<=b）求arr中有多少个子数组，累加和在[a,b]这个范围上，返回达标的子数组数量给定一个数组arr，两个整数lower和upper， 返回arr中有多少个子数组的累加和在[lower,upper]范围上
●	滑动窗口中位数
 #体系班37 #有序表 #滑动窗口
●	设计一种复杂度为O(logN)高效数据结构
 #体系班37 #有序表
●	设计一个结构包含如下两个方法： void add(int index, int num)：把num加入到index位置 int get(int index) ：取出index位置的值 void remove(int index) ：把index位置上的值删除 要求三个方法时间复杂度O(logN)
●	红黑树
 #体系班37 #有序表
●	给定一个正整数N，返回至少使用多少袋子装苹果|小虎买苹果
#体系班38 #打表法
●	小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量。 1）能装下6个苹果的袋子 2）能装下8个苹果的袋子 小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满。 给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1
●	牛羊吃N份青草谁会赢
#体系班38 #打表法
●	给定一个正整数N，表示有N份青草统一堆放在仓库里有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草不管是牛还是羊，每一轮能吃的草量必须是：1，4，16，64…(4的某次方) 谁最先把草吃完，谁获胜假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定根据唯一的参数N，返回谁会赢
●	给定一个参数N，返回是不是可以表示成若干连续正数和的数
#体系班38 #打表法
●	定义一种数：可以表示成若干（数量>1）连续正数和的数 比如: 5 = 2+3，5就是这样的数 12 = 3+4+5，12就是这样的数 1不是这样的数，因为要求数量大于1个、连续正数和 2 = 1 + 1，2也不是，因为等号右边不是连续正数 给定一个参数N，返回是不是可以表示成若干连续正数和的数
●	打怪兽需要花的最小钱数
#体系班38 #根据数据量猜解法 #看菜下饭
●	int[] d，d[i]：i号怪兽的能力int[] p，p[i]：i号怪兽要求的钱 开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。 如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽， 然后怪兽就会加入你，他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力， 你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。 返回通过所有的怪兽，需要花的最小钱数。
●	非负数组子序列中累加和%m的最大值
 #体系班39 #根据数据量猜解法 #看菜下饭
●	给定一个非负数组arr，和一个正数m 返回arr的所有子序列中累加和%m之后的最大值。
●	背包中有多少种零食放法
 #体系班39 #根据数据量猜解法 #看菜下饭
●	卡特兰数
 #体系班39 #卡特兰数
●	左右括号各N个组合出来的括号配对是否合法
 #体系班39 #卡特兰数
●	二叉树N个节点无差别能形成多少种不同的结构
 #体系班39 #卡特兰数
●	正整数组子数组累加和等于K的最大长度|累加和等于sum的子数组最长多长
 #体系班40 #数组累加和问题三连 #滑动窗口
●	给定一个正整数组成的无序数组arr，给定一个正整数值K找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的 返回其长度
●	整数数组子数组累加和等于K的最大长度
 #体系班40 #数组累加和问题三连 #预处理数组
●	给定一个整数组成的无序数组arr，值可能正、可能负、可能0给定一个整数值K 找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的 返回其长度
●	整数组成的无序数组中子数组的累加和小于等于K的最大长度
 #体系班40 #数组累加和问题三连 #可能性舍弃
●	给定一个整数组成的无序数组arr，值可能正、可能负、可能0给定一个整数值K 找到arr的所有子数组里，哪个子数组的累加和<=K，并且是长度最大的 返回其长度 复杂度: O (N)的解法 复杂度: O (N* logN)的解法 ```text 建立累加和help数组的辅助help数组, help数组维持只升不降, 用二分法求解 ```
●	整数数组中-1的数量和1的数量是一样多的子数组最大长度
 #体系班40 #数组累加和问题三连
●	一个数组中，所有的值任一有正有负有0，我想找到有一个子数组，我要求在这个数组中-1的数量和1的数量必须是一样多的，哪一个子数组是最长的？
●	整数数组子数组平均值小于等于V的最大长度
 #体系班40 #数组累加和问题三连
●	给定一个整型数组arr，和一个整数K，求平均值小于等于K的所有子数组中，最大长度是多少数据规模: 1000 --- 给定一个数组arr,给定一个值v 求子数组平均值小于等于v的最长子数组长度 --- 数据规模: 1000 你写一个N平方的也能过 推公式的做化简-->N*log N 这个的启发性思路，其实来自股票问题那个动态规划。尽量让一个指标，只和自己的属性有关  时间复杂度能做到O(N) 利用数组三连问题，第三连 都减去K之后，求数组累加和<=0的最大子数组
●	原地旋转正方形矩阵
 #体系班40 #宏观调度
●	给定一个正方形矩阵matrix，原地调整成顺时针90度转动的样子 ``` a  b  c            g  d  a d  e  f            h  e  b g  h  i            i  f  c ```
●	转圈打印矩阵
 #体系班40 #宏观调度
●	给定一个长方形矩阵matrix，实现转圈打印 ``` a  b  c  d   e  f  g  h   i  j  k  L   ``` 打印顺序：a b c d h L k j I e f g
●	转圈打印N边星号正方形
 #体系班40 #宏观调度
●	输入N，在控制台上输出初始边长为N的图案
 
●	zigzag打印矩阵
 #体系班40 #宏观调度
●	给定一个正方形或者长方形矩阵matrix，实现zigzag打印 0 1 2    3 4 5    6 7 8    打印: 0 1 3 6 4 2 5 7 8
●	非负数组切分成左右两部分累加和的最大值的数组
#动态规划 #DP #四边形不等式  #体系班41
●	给定一个非负数组arr，长度为N，那么有N-1种方案可以把arr切成左右两部分 每一种方案都有，min{左部分累加和，右部分累加和} 求这么多方案中，min{左部分累加和，右部分累加和}的最大值是多少？ 整个过程要求时间复杂度O(N)
●	合并石子的得分
#动态规划 #DP #四边形不等式  #体系班41
●	摆放着n堆石子。现要将石子有次序地合并成一堆规定每次只能选相邻的2堆石子合并成新的一堆， 并将新的一堆石子数记为该次合并的得分 求出将n堆石子合并成一堆的最小得分（或最大得分）合并方案
●	画匠问题
#动态规划 #DP #四边形不等式  #体系班41
●	给定一个整型数组 arr，数组中的每个值都为正数，表示完成一幅画作需要的时间，再 给定 一个整数 num，表示画匠的数量，每个画匠只能画连在一起的画作。所有的画家 并行工作，请 返回完成所有的画作需要的最少时间。【举例】 arr=[3,1,4]，num=2。 最好的分配方式为第一个画匠画 3 和 1，所需时间为 4。第二个画匠画 4，所需时间 为 4。 因为并行工作，所以最少时间为 4。如果分配方式为第一个画匠画 3，所需时 间为 3。第二个画 匠画 1 和 4，所需的时间为 5。那么最少时间为 5，显然没有第一 种分配方式好。所以返回 4。 arr=[1,1,1,4,3]，num=3。 最好的分配方式为第一个画匠画前三个 1，所需时间为 3。第二个画匠画 4，所需时间 为 4。 第三个画匠画 3，所需时间为 3。返回 4。
●	邮局选址问题
#动态规划 #DP #四边形不等式  #体系班42 #一个样本做行一个样本做列   #四边形不等式  #预处理数组
●	一条直线上有居民点，邮局只能建在居民点上。给定一个有序正数数组arr，每个值表示 居民点的一维坐标，再给定一个正数 num，表示邮局数量。选择num个居民点建立num个 邮局，使所有的居民点到最近邮局的总距离最短，返回最短的总距离   【举例】    arr=[1,2,3,4,5,1000]，num=2。    第一个邮局建立在 3 位置，第二个邮局建立在 1000 位置。那么 1 位置到邮局的距离 为 2， 2 位置到邮局距离为 1，3 位置到邮局的距离为 0，4 位置到邮局的距离为 1， 5 位置到邮局的距 离为 2，1000 位置到邮局的距离为 0。这种方案下的总距离为 6， 其他任何方案的总距离都不会 比该方案的总距离更短，所以返回6
●	丢棋子问题
#动态规划 #DP #四边形不等式  #体系班42 #寻找业务限制的尝试模型
●	一座大楼有 0~N 层，地面算作第 0 层，最高的一层为第 N 层。已知棋子从第 0 层掉落肯定 不会摔碎，从第 i 层掉落可能会摔碎，也可能不会摔碎(1≤i≤N)。给定整数 N 作为楼层数， 再给定整数 K 作为棋子数，返 回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔 的最少次数。一次只能扔一个棋子。示例1: ```text 输入: N=10，K=1 返回: 10 说明: 因为只有 1 棵棋子，所以不得不从第 1 层开始一直试到第 10 层，在最差的情况 下， 即第 10 层 是不会摔坏的最高层，最少也要扔 10 次。 ``` 示例2: ```text 输入: N=3，K=2 返回: 2 说明: 先在 2 层扔 1 棵棋子，如果碎了，试第 1 层，如果没碎，试第 3 层。  ``` 示例3: ```text 输入: N=105，K=2 返回: 14 说明: 第一个棋子先在14层扔，碎了则用仅存的一个棋子试1~13层 若没碎，第一个棋子继续在27层扔，碎了则用仅存的一个棋子试15~26层 若没碎，第一个棋子继续在39层扔，碎了则用仅存的一个棋子试28~38层 若没碎，第一个棋子继续在50层扔，碎了则用仅存的一个棋子试40~49层 若没碎，第一个棋子继续在60层扔，碎了则用仅存的一个棋子试51~59层 若没碎，第一个棋子继续在69层扔，碎了则用仅存的一个棋子试61~68层 若没碎，第一个棋子继续在77层扔，碎了则用仅存的一个棋子试70~76层 若没碎，第一个棋子继续在84层扔，碎了则用仅存的一个棋子试78~83层 若没碎，第一个棋子继续在90层扔，碎了则用仅存的一个棋子试85~89层 若没碎，第一个棋子继续在95层扔，碎了则用仅存的一个棋子试91~94层 若没碎，第一个棋子继续在99层扔，碎了则用仅存的一个棋子试96~98层 若没碎，第一个棋子继续在102层扔，碎了则用仅存的一个棋子试100、101层 若没碎，第一个棋子继续在104层扔，碎了则用仅存的一个棋子试103层 若没碎，第一个棋子继续在105层扔，若到这一步还没碎，那么105便是结果 ```
●	464. 我能赢吗
#动态规划 #DP #状态压缩  #体系班43 #Medium #LeetCode
●	TSP问题
#动态规划 #DP #状态压缩  #体系班43
●	铺瓷砖问题
#动态规划 #DP #状态压缩  #体系班43
●	DC3生成后缀数组
#后缀数组  #体系班44
●	1163. 按字典序排在最后的子串
#后缀数组  #体系班44 #字典序 #Hard #LeetCode
●	给你一个字符串 s，找出它的所有子串并按字典序排列，返回排在最后的那个子串。 示例 1： ``` 输入："abab" 输出："bab" 解释：我们可以找出 7 个子串 ["a", "ab", "aba", "abab", "b", "ba", "bab"]。按字典序排在最后的子串是 "bab"。 ``` 示例 2： ``` 输入："leetcode" 输出："tcode" ``` 提示： 1 <= s.length <= 4 * 10^5 s 仅含有小写英文字符。
●	字符串插入形成的字典序最大结果
#后缀数组  #体系班45 #字典序
●	给定两个字符串str1和str2，想把str2整体插入到str1中的某个位置形成最大的字典序  返回字典序最大的结果
●	321.拼接最大数
#后缀数组  #体系班45 #字典序 #Hard #LeetCode
●	给两个长度分别为M和N的整型数组nums1和nums2，其中每个值都不大于9，再给定一个正数K。 你可以在nums1和nums2中挑选数字，要求一共挑选K个，并且要从左到右挑。返回所有可能的结果中，代表最大数字的结果。
●	两个字符串的最长公共子串 后缀数组解法
#后缀数组  #体系班45 #字典序
●	打气球的最大分数
#体系班46  #外部信息简化
●	给定一个数组 arr，代表一排有分数的气球。每打爆一个气球都能获得分数，假设打爆气 球 的分数为 X，获得分数的规则如下:  1) 如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R。 获得分数为 LXR。  2) 如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边所有气球都已经被打爆。获得分数为 LX。  3) 如果被打爆气球的左边所有的气球都已经被打爆;如果被打爆气球的右边有没被打爆的 气球，找到离被打爆气球最近的气球，假设分数为 R;如果被打爆气球的右边所有气球都 已经 被打爆。获得分数为 XR。  4) 如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为 X。 目标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不同的总分，请返回能获得的最大分数。 【举例】 arr = {3,2,5} 如果先打爆3，获得3* 2;再打爆2，获得2* 5;最后打爆5，获得5;最后总分21 如果先打爆3，获得3* 2;再打爆5，获得2* 5;最后打爆2，获得2;最后总分18 如果先打爆2，获得325;再打爆3，获得3* 5;最后打爆5，获得5;最后总分50 如果先打爆2，获得32 5;再打爆5，获得3* 5;最后打爆3，获得3;最后总分48 如果先打爆5，获得2* 5;再打爆3，获得3* 2;最后打爆2，获得2;最后总分18 如果先打爆5，获得2* 5;再打爆2，获得3* 2;最后打爆3，获得3;最后总分19 返回能获得的最大分数为50
●	546. 移除盒子
#体系班46  #外部信息简化  #Hard #LeetCode
●	给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1），这样一轮之后你将得到 k*k 个积分。 当你将所有盒子都去掉之后，求你能获得的最大积分和。 示例 1： ```text 输入: [1, 3, 2, 2, 2, 3, 4, 3, 1] 输出: 23 ``` 解释: ```text [1, 3, 2, 2, 2, 3, 4, 3, 1]  ----> [1, 3, 3, 4, 3, 1] (3*3=9 分)  ----> [1, 3, 3, 3, 1] (1*1=1 分)  ----> [1, 1] (3*3=9 分)  ----> [] (2*2=4 分) ``` 提示：盒子的总数 n 不会超过 100。
●	字符消除游戏
#体系班46  #外部信息简化
●	如果一个字符相邻的位置没有相同字符，那么这个位置的字符出现不能被消掉比如:"ab"，其中a和b都不能被消掉 如果一个字符相邻的位置有相同字符，就可以一起消掉 比如:"abbbc"，中间一串的b是可以被消掉的，消除之后剩下"ac" 某些字符如果消掉了，剩下的字符认为重新靠在一起 给定一个字符串，你可以决定每一步消除的顺序，目标是请尽可能多的消掉字符，返回最少的剩余字符数量 比如："aacca", 如果先消掉最左侧的"aa"，那么将剩下"cca"，然后把"cc"消掉，剩下的"a"将无法再消除，返回1 但是如果先消掉中间的"cc"，那么将剩下"aaa"，最后都消掉就一个字符也不剩了，返回0，这才是最优解。 再比如："baaccabb"， 如果先消除最左侧的两个a，剩下"bccabb"， 如果再消除最左侧的两个c，剩下"babb"， 最后消除最右侧的两个b，剩下"ba"无法再消除，返回2 而最优策略是： 如果先消除中间的两个c，剩下"baaabb"， 如果再消除中间的三个a，剩下"bbb"， 最后消除三个b，不留下任何字符，返回0，这才是最优解
●	子数组长度不超过M的最大累加和
#体系班46  #外部信息简化
●	给定一个数组arr，和一个正数M，返回在arr的子数组在长度不超过M的情况下，最大的累加和
●	哈夫曼树
#体系班46  #外部信息简化 #哈夫曼树 #霍夫曼树
●	664. 奇怪的打印机
#体系班47  #外部信息简化 #Hard #LeetCode
●	有台奇怪的打印机有以下两个特殊要求：打印机每次只能打印同一个字符序列。 每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。 给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。 示例 1: ```text 输入: "aaabbb" 输出: 2 解释: 首先打印 "aaa" 然后打印 "bbb"。 ``` 示例 2: ```text 输入: "aba" 输出: 2 解释: 首先打印 "aaa" 然后在第二个位置打印 "b" 覆盖掉原来的字符 'a'。 ``` 提示: 输入字符串的长度不会超过 100。
●	还原数组丢失的数字
#体系班47  #外部信息简化
●	整型数组arr长度为n(3 <= n <= 10^4)，最初每个数字是<=200的正数且满足如下条件：  1. 0位置的要求: arr[0] <= arr[1] 2. 1位置的要求: arr[n-1] <= arr[n-2] 3. 中间i位置的要求: aarr[i] <= max(arr[i-1], arr[i+1]) 但是在arr有些数字丢失了，比如k位置的数字之前是正数， 丢失之后k位置的数字为0。 请你根据上述条件， 计算可能有多少种不同的arr可以满足以上条件。 比如 [6,0,9] 只有还原成 [6,9,9]满足全部三个条件，所以返回1种。
●	网络带宽
#网络流 #体系班47
●	最大网络流Dinic算法
●	一根长度为K的绳子，最多能盖住几个点
#大厂刷题班01 #贪心 #单调性 #滑动窗口
●	给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置 给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点 绳子的边缘点碰到X轴上的点，也算盖住
●	统计目录下的文件数量
#大厂刷题班01 #宽度优先遍历 #BFS #深度优先遍历 #DFS #图的遍历
●	给定一个文件目录的路径，写一个函数统计这个目录下所有的文件数量并返回隐藏文件也算，但是文件夹不算
●	返回离非负整数num最近的2的某次方
#大厂刷题班01
●	给定一个非负整数num，如何不用循环语句，返回>=num，并且离num最近的，2的某次方
●	相邻字符的交换次数
#大厂刷题班01
●	一个数组中只有两种字符'G'和'B’，可以让所有的G都放在左侧，所有的B都放在右侧, 或者可以让所有的G都放在右侧，所有的B都放在左侧, 但是只能在相邻字符之间进行交换操作，返回至少需要交换几次
●	494.数组中添加加减运算符得到指定值的所有方法
#大厂刷题班01 #DP #动态规划 #Medium  #LeetCode #腾讯
●	给定一个数组arr，你可以在每个数字之前决定+或者-, 但是必须所有数字都参与, 再给定一个数target，请问最后算出target的方法数是多少？
●	二维数组最大递增链的长度
#大厂刷题班01 #递归 #傻缓存
●	给定一个二维数组matrix，可以从任何位置出发，每一步可以走向上、下、左、右，四个方向。返回最大递增链的长度。  例子：   matrix =    5  4  3   3  1  2   2  1  3   从最中心的1出发，是可以走出1 2 3 4 5的链的，而且这是最长的递增链。所以返回长度5
●	清空所有怪兽需要的AOE技能次数
#大厂刷题班01 #线段树
●	给定两个非负数组x和hp，长度都是N，再给定一个正数rangex有序， x[i]表示i号怪兽在x轴上的位置；hp[i]表示i号怪兽的血量 range表示法师如果站在x位置，用AOE技能打到的范围是： [x-range,x+range]，被打到的每只怪兽损失1点血量 返回要把所有怪兽血量清空，至少需要释放多少次AOE技能？
●	能获得的最好收入
#大厂刷题班02 #有序表
●	给定数组hard和money，长度都为N, hard[i]表示i号的难度， money[i]表示i号工作的收入给定数组ability，长度都为M，ability[j]表示j号人的能力, 每一号工作，都可以提供无数的岗位，难度和收入都一样 但是人的能力必须>=这份工作的难度，才能上班. 返回一个长度为M的数组ans，ans[j]表示j号人能获得的最好收入
●	无序数组需要排序的最短子数组长度
#大厂刷题班02
●	给定一个数组arr，只能对arr中的一个子数组排序，但是想让arr整体都有序返回满足这一设定的子数组中，最短的是多长
●	数据结构设计之O(1)实现setAll
#大厂刷题班02
●	一种消息接收并打印的结构设计
#大厂刷题班02
●	已知一个消息流会不断地吐出整数 1~N，但不一定按照顺序吐出。如果上次打印的数为 i， 那么当 i+1 出现时，请打印 i+1 及其之后接收过的并且连续的所有数，直到 1~N 全部接收 并打印完，请设计这种接收并打印的结构。
●	100万阶乘后面有多少个0?
#大厂刷题班02
●	买饮料
#大厂刷题班02 #携程
●	贩卖机只支持硬币支付，且收退都只支持10 ，50，100三种面额一次购买只能出一瓶可乐，且投钱和找零都遵循优先使用大钱的原则 需要购买的可乐数量是m， 其中手头拥有的10、50、100的数量分别为a、b、c 可乐的价格是x(x是10的倍数) 请计算出需要投入硬币次数？
●	司机最高总收入
#大厂刷题班02 #携程
●	现有司机N*2人，调度中心会将所有司机平分给A、B两个区域第 i 个司机去A可得收入为income[i][0]， 第 i 个司机去B可得收入为income[i][1]， 返回所有调度方案中能使所有司机总收入最高的方案，是多少钱
●	与 target的距离是K的所有节点
#大厂刷题班03
●	给定三个参数:二叉树的头节点head,树上某个节点 target,正数K 从 target开始，可以向上走或者向下走 返回与 target的距离是K的所有节点
●	最多可以同时有多少场比赛
#大厂刷题班03 #贪心 #窗口
●	给定一个数组arr，代表每个人的能力值。再给定一个非负数k如果两个人能力差值正好为k，那么可以凑在一起比赛 一局比赛只有两个人 返回最多可以同时有多少场比赛
●	3.无重复字符的最长子串
#大厂刷题班03  #Medium  #LeetCode
●	求一个字符串中，最长无重复字符子串长度
●	字符串种类
#大厂刷题班03
●	只由小写字母（a~z）组成的一批字符串 都放在字符类型的数组String[] arr中 如果其中某两个字符串所含有的字符种类完全一样 就将两个字符串算作一类 比如：baacbba和bac就算作一类 返回arr中有多少类？
●	1139.最大的以 1 为边界的正方形
#大厂刷题班03  #Medium  #LeetCode
●	给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。  ```text 示例 1： 输入：grid = [[1,1,1],[1,0,1],[1,1,1]] 输出：9 示例 2： 输入：grid = [[1,1,0,0]] 输出：1   提示： 1 <= grid.length <= 100   1 <= grid[0].length <= 100   grid[i][j] 为 0 或 1   ```
●	乘客坐船使用的最少船数
#大厂刷题班03 #贪心 #考察Coding #中兴
●	给定一个数组arr，长度为N且每个值都是正数，代表N个人的体重。再给定一个正数 limit，代表一艘船的载重。  以下是坐船规则，   1)每艘船最多只能做两人;   2)乘客 的体重和不能超过limit   返回如果同时让这N个人过河最少需要几条船。
●	1755. 最接近目标值的子序列和
 #Hard  #LeetCode #大厂刷题班03 #分治
●	514. 自由之路
#大厂刷题班03 #Hard  #LeetCode
●	视频游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。-  给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。 最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。 旋转 ring 拼出 key 字符 key[i] 的阶段中： 您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。 如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。
●	输入: ring = "godding", key = "gd" 输出: 4 解释:     对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。     对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring "godding" 2步使它变成 "ddinggo"。     当然, 我们还需要1步进行拼写。     因此最终的输出是 4。 提示：  ring 和 key 的字符串长度取值范围均为 1 至 100； 两个字符串中都只有小写字符，并且均可能存在重复字符； 字符串 key 一定可以由字符串 ring 旋转拼出。
 
●	非常频繁的数组查询
#大厂刷题班04 #字节
●	数组为{3, 2, 2, 3, 1}，查询为(0, 3, 2)意思是在数组里下标0~3这个范围上，有几个2？答案返回2。 假设给你一个数组arr， 对这个数组的查询非常频繁，都给出来 请返回所有查询的结果
●	子数组的最大累加和
#大厂刷题班04
●	返回一个数组中，子数组最大累加和
●	不能相邻的最大子序列累加和
#大厂刷题班04 #美团 #从左往右的尝试模型
●	返回一个数组中，选择的数字不能相邻的情况下，最大子序列累加和
●	子矩阵最大累加和
#大厂刷题班04  #LeetCode   #Hard
●	返回一个二维数组中，子矩阵最大累加和
●	135.分糖果问题
#大厂刷题班04  #Hard  #LeetCode #贪心 #预处理
●	原问题
●	老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。你需要按照以下要求，帮助老师给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？
●	示例 1： 输入：[1,0,2] 输出：5 解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。
●	示例 2： 输入：[1,2,2] 输出：4
●	 解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
●	进阶问题
●	在原问题的基础上，增加一个原则： 相邻的孩子间如果分数一样，分的糖果数必须一样, 返回至少需要分多少糖
●	小人过有鳄鱼的河
#大厂刷题班04  #博弈论
●	生成长度为size的达标数组
#大厂刷题班04
●	生成长度为size的达标数组，什么叫达标？达标：对于任意的 i<k<j，满足 [i] + [j] != [k] * 2 给定一个正数size，返回长度为size的达标数组
●	97.字符串交错组成
#大厂刷题班04  #LeetCode   #Medium #动态规划 #DP #一个样本做行一个样本做列 #样本对应模型
●	给定三个字符串str1、str2和aim，如果aim包含且仅包含来自str1和str2的所有字符， 而且在aim中属于str1的字符之间保持原来在str1中的顺序， 属于str2的字符之间保持 原来在str2中的顺序，那么称aim是str1和str2的交错组成。实现一个函数，判断aim是 否是str1和str2交错组成 【举例】 str1="AB"，str2="12"。那么"AB12"、"A1B2"、"A12B"、"1A2B"和"1AB2"等都是 str1 和 str2 的 交错组成
●	218.大楼轮廓线问题
#大厂刷题班04  #Hard   #LeetCode
●	给定一个 N×3 的矩阵 matrix，对于每一个长度为 3 的小数组 arr，都表示一个大楼的三个数 据。 arr[0]表示大楼的左边界，arr[1]表示大楼的右边界，arr[2]表示大楼的高度(一定大于 0)。 每座大楼的地基都在 X 轴上，大楼之间可能会有重叠，请返回整体的轮廓线数组。 【举例】  ```text matrix ={{2,5,6}, {1,7,4}, {4,6,7}, {3,6,5}, {10,13,2},            {9,11,3}, {12,14,4},{10,12,5} }   返回: {{1,2,4},{2,4,6}, {4,6,7}, {6,7,4}, {9,10,3},        {10,12,5}, {12,14,4}}   ```
●	根据二叉树后序遍历结果生成整颗树
#二叉树 #大厂刷题班05
●	已知一棵搜索二叉树上没有重复值的节点， 现在有一个数组arr，是这棵搜索二叉树后序遍历的结果 请根据arr生成整棵树并返回头节点
●	1008.前序遍历构造二叉搜索树
 #Medium  #LeetCode
●	返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。 (回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 < node.val，而 node.right 的任何后代，值总 > node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。） 题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。  ``` 示例： 输入：[8,5,1,7,10,12] 输出：[8,5,10,1,7,null,12]   提示： 1 <= preorder.length <= 100 1 <= preorder[i] <= 10^8 preorder 中的值互不相同 ```
 
●	105.用先序数组和中序数组重建一棵树
 #LeetCode   #Medium
●	根据一棵树的前序遍历与中序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 ```text 例如，给出:   前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder =  [9,3,15,20,7] 返回如下的二叉树：     3    / \   9  20     /  \    15   7 ``` --- ```text 前序遍历 preorder = [1, 2, 4, 5, 3, 6 7] 中序遍历 inorder =  [4, 2, 5, 1 6, 3, 7] 定义递归函数:   头 f(先, 0, 6, 中, 0, 6)    含义:    利用先序的0~6, 和 中序的 0~6 这一段 建出整棵树, 把头结点返回 ```
●	二叉树上的相等子树
#二叉树 #大厂刷题班05 #二叉树的递归套路  #阿里
●	如果一个节点X，它左树结构和右树结构完全一样 那么我们说以X为头的子树是相等子树 给定一棵二叉树的头节点head 返回head整棵树上有多少棵相等子树
●	72.编辑距离问题: 经典中的经典
#动态规划 #DP #一个样本做行一个样本做列  #大厂刷题班05 #样本对应模型
●	给定两个字符串str1和str2，再给定三个整数ic、dc和rc，分别代表插入、删 除和替换一个字符的代价，返回将str1编辑成str2的最小代价。 【举例】 str1="abc"，str2="adc"，ic=5，dc=3，rc=2 从"abc"编辑成"adc"，把'b'替换成'd'是代价最小的，所以返回2  str1="abc"，str2="adc"，ic=5，dc=3，rc=100 从"abc"编辑成"adc"，先删除'b'，然后插入'd'是代价最小的，所以返回8 str1="abc"，str2="abc"，ic=5，dc=3，rc=2 不用编辑了，本来就是一样的字符串，所以返回0
●	问字符串s2最少删除多少字符可以成为s1的子串
#动态规划 #DP #一个样本做行一个样本做列  #大厂刷题班05 #样本对应模型
●	给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？ 比如 s1 = "abcde"，s2 = "axbc" 返回1。s2删掉'x'就是s1的子串了。
●	最大子数组异或和
#大厂刷题班06 #网易  #前缀树 #Trie
●	一个数组的异或和是指数组中所有的数异或在一起的结果 给定一个数组arr，求最大子数组异或和。
●	421.数组中两个数的最大异或值
#大厂刷题班06  #Medium  #LeetCode #前缀树 #Trie
●	给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j < n 。 进阶：你可以在 O(n) 的时间解决这个问题吗？  ``` 示例 1： 输入：nums = [3,10,5,25,2,8] 输出：28 解释：最大运算结果是 5 XOR 25 = 28. 示例 2： 输入：nums = [0] 输出：0 示例 3： 输入：nums = [2,4] 输出：6 示例 4： 输入：nums = [8,10,2] 输出：10 示例 5： 输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70] 输出：127  ``` 提示： 1 <= nums.length <= 2 * 10^4 0 <= nums[i] <= 2^31 - 1
●	1707.与数组中元素的最大异或值
#大厂刷题班06 #前缀树 #Trie
●	给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。 第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ， 其中所有 j 均满足 nums[j] <= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。 返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。  ``` 示例 1： 输入：nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]] 输出：[3,3,7] 解释： 1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。 2) 1 XOR 2 = 3. 3) 5 XOR 2 = 7. 示例 2： 输入：nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]] 输出：[15,-1,5] ``` 提示： 1 <= nums.length, queries.length <= 10^5 queries[i].length == 2 0 <= nums[j], xi, mi <= 10^9
●	数组中得到最多异或和为0的子数组划分问题
#大厂刷题班06  #Hard  #LeetCode  #网易 #假设答案法 #从左往右的尝试模型
●	数组中所有数都异或起来的结果，叫做异或和 给定一个数组arr，可以任意切分成若干个不相交的子数组 其中一定存在一种最优方案，使得切出异或和为0的子数组最多 返回这个最多数量
●	Nim博弈问题
#大厂刷题班06
●	给定一个非负数组，每一个值代表该位置上有几个铜板。a和b玩游戏，a先手，b后手， 轮到某个人的时候， 只能在一个位置上拿任意数量的铜板，但是不能不拿。谁最先把铜 板拿完谁赢。假设a和b都极度聪明，请返回获胜者的名字
●	非负数组中两个数相与的最大结果
#大厂刷题班07
●	给定一个非负组成的数组，长度一定大于1 想知道数组中哪两个数&的结果最大 返回这个最大结果
●	968.相机最小覆盖问题
#大厂刷题班07 #Hard  #LeetCode  #贪心 #二叉树的递归套路 #腾讯
●	给定一棵二叉树的头节点head，如果在某一个节点x上放置相机，那么x的父节点、x的所 有子节点以及x都可以被覆盖。返回如果要把所有数都覆盖，至少需要多少个相机。 示例 1：  ``` 输入：[0,0,null,0,0] 输出：1 解释：如图所示，一台摄像头足以监控所有节点。 ```
 
●	 示例 2：  ``` 输入：[0,0,null,0,null,0,null,null,0] 输出：2 解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
 
●	 提示： 给定树的节点数的范围是 [1, 1000]。 每个节点的值都是 0。  LeetCode答案直接是最优贪心解, 如果你没有那么聪明, 所有可能性都列清楚, 也能过   套路此时就显示它的作用了, 你没有那么聪明也能靠套路搞出来
●	无序数组如果排序之后相邻数之间的最大差值
#大厂刷题班07 #难住ACM国手的题  #SuperHard #硬记
●	给定一个无序数组arr，返回如果排序之后，相邻数之间的最大差值 {3,1,7,9}，如果排序后{1,3,7,9}，相邻数之间的最大差值来自3和7，返回4 要求：不能真的进行排序，并且要求在时间复杂度O(N)内解决
●	平方之后的结果数
#大厂刷题班07 #双指针
●	给定一个有序数组arr，其中值可能为正、负、0 返回arr中每个数都平方之后不同的结果有多少种？
●	数组中不同数字的个数
#大厂刷题班07 #双指针
●	给定一个数组arr，先递减然后递增，返回arr中有多少个不同的数字？
●	使用单词表拼接长字符串的方法数
#大厂刷题班07 #从左往右的尝试模型 #前缀树 #Trie
●	假设所有字符都是小写字母.   长(大)字符串是str arr是去重的单词表, 每个单词都不是空字符串且可以使用任意次 使用arr中的单词有多少种拼接str的方式，返回方法数.
●	字符串拼接的最大分数
#大厂刷题班07 #从左往右的尝试模型 #前缀树 #Trie
●	给你一个字符串它可以被array数组里面的东西分解。但是每一个东西给你个分儿，17分，18分, 29分，2分，6分，问你拼出str，怎么一种拼接的方式能让最后的总得分最大
●	计算str表达式结果
#大厂刷题班08 #括号嵌套系列问题
●	给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘除符号和左右 括号，返回公式的计算结果。 【举例】 ``` str="48*((70-65)-43)+8*1"，返回-1816。 str="3+1*4"，返回7。 str="3+(1*4)"，返回7。 ``` 【说明】 1.可以认为给定的字符串一定是正确的公式，即不需要对str做公式有效性检查。  2.如果是负数，就需要用括号括起来，比如"4* (-3)"。但如果负数作为公式的开头 或括号部分的开头，则可以没有括号，比如"-3* 4"和"(-3* 4)"都是合法的。  3.不用考虑计算过程中会发生溢出的情况。
●	772.基本计算器 III
#括号嵌套系列问题 #LeetCode   #Hard
●	实现一个基本的计算器来计算简单的表达式字符串。 表达式字符串只包含非负整数，算符 +、-、*、/ ，左括号 ( 和右括号 ) 。整数除法需要 向下截断 。 你可以假定给定的表达式总是有效的。所有的中间结果的范围为 [-231, 231 - 1] 。  示例 1： ``` 输入：s = "1+1" 输出：2 示例 2： 输入：s = "6-4/2" 输出：4 示例 3： 输入：s = "2*(5+5*2)/3+(6/2+8)" 输出：21 示例 4： 输入：s = "(2+6*3+5-(3*14/7+2)*5)+3" 输出：-12 示例 5： 输入：s = "0" 输出：0  ``` 提示： 1 <= s <= 104 s 由整数、'+'、'-'、'*'、'/'、'(' 和 ')' 组成 s 是一个 有效的 表达式   进阶：你可以在不使用内置库函数的情况下解决此问题吗？
●	394.字符串解码
#括号嵌套系列问题 #LeetCode    #Medium
●	给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。  示例 1： ``` 输入：s = "3[a]2[bc]" 输出："aaabcbc" 示例 2： 输入：s = "3[a2[c]]" 输出："accaccacc" 示例 3： 输入：s = "2[abc]3[cd]ef" 输出："abcabccdcdcdef" 示例 4： 输入：s = "abc3[cd]xyz" 输出："abccdcdcdxyz" ``` --- 大写字母压缩规则如下： AAAB可以压缩为A3B（单字符压缩不加括号） ABABA可以压缩为（AB）2A，（多字符串压缩才加括号） 输入数据保证不会出现冗余括号，且表示重复的数字一定合法且大于1， 即不会出现下列情况： (A)2B---应该为A2B, ((AB))2C---应该为（AB）2C， (A)B---应该为AB, A1B, (AB)1C---应该为ABC 另外数字可能出现多位数即A11B或者（AB）10C或者A02这种情况 A11B = AAAAAAAAAAAB, A02=AA
●	726.原子的数量
#括号嵌套系列问题 #LeetCode   #Hard
●	给定一个化学式formula（作为字符串），返回每种原子的数量。 原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。 如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。 两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。 一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。 给定一个化学式，输出所有原子的数量。格式为：第一个（按字典序）原子的名子，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。 示例 1: ``` 输入:  formula = "H2O" 输出: "H2O" 解释:  原子的数量是 {'H': 2, 'O': 1}。 示例 2: 输入:  formula = "Mg(OH)2" 输出: "H2MgO2" 解释:  原子的数量是 {'H': 2, 'Mg': 1, 'O': 2}。 示例 3: 输入:  formula = "K4(ON(SO3)2)2" 输出: "K4N2O14S4" 解释:  原子的数量是 {'K': 4, 'N': 2, 'O': 14, 'S': 4}。 ``` 注意: 所有原子的第一个字母为大写，剩余字母都是小写。 formula的长度在[1, 1000]之间。 formula只包含字母、数字和圆括号，并且题目中给定的是合法的化学式。
●	11.盛最多水的容器
#大厂刷题班08  #Medium  #LeetCode #硬记
●	蛇走的轨迹问题
#大厂刷题班08 #寻找业务限制的尝试模型
●	给定一个矩阵matrix，值有正、负、0 蛇可以空降到最左列的任何一个位置，初始增长值是0 蛇每一步可以选择右上、右、右下三个方向的任何一个前进 沿途的数字累加起来，作为增长值；但是蛇一旦增长值为负数，就会死去 蛇有一种能力，可以使用一次：把某个格子里的数变成相反数 蛇可以走到任何格子的时候停止 返回蛇能获得的最大增长值 --- 给定一个二维数组matrix，每个单元都是一个整数，有正有负。最开始的时候小Q操纵 一条长度为0的蛇蛇从矩阵最左侧任选一个单元格进入地图，蛇每次只能够到达当前位 置的右上相邻，右侧相邻和右下相邻的单元格。蛇蛇到达一个单元格后，自身的长度会 瞬间加上该单元格的数值，任何情况下长度为负则游戏结束。小Q是个天才，他拥有一 个超能力，可以在游戏开始的时候把地图中的某一个节点的值变为其相反数(注:最多 只能改变一个节点)。问在小Q游戏过程中，他的蛇蛇最长长度可以到多少? 比如: 1 -4  10 3 -2 -1 2 -1  0 0  5 -2 最优路径为从最左侧的3开始，3 -> -4(利用能力变成4) -> 10。所以返回17。
●	二维数组中可以走出的单词
 #大厂刷题班08 #样本对应模型
●	给定一个char[][] matrix，也就是char类型的二维数组，再给定一个字符串word， 可以从任何一个某个位置出发，可以走上下左右，能不能找到word？       char[][] m = {  { 'a', 'b', 'z' },                           { 'c', 'd', 'o' },                           { 'f', 'e', 'o' },     设定1：可以走重复路的情况下，返回能不能找到   比如，word = "zoooz"，是可以找到的，z -> o -> o -> o -> z，因为允许走一条路径中已经走过的字符   设定2：不可以走重复路的情况下，返回能不能找到   比如，word = "zoooz"，是不可以找到的，因为允许走一条路径中已经走过的字符不能重复走
●	Step sum
#大厂刷题班09 #二分法
●	定义何为step sum？ 比如680，680 + 68 + 6 = 754，680的step sum叫754 给定一个正数num，判断它是不是某个数的step sum
●	最少按几次开关才能点亮所有的灯
#动态规划 #DP #从左往右的尝试模型 #大厂刷题班09 #头条
●	给定一个数组arr，长度为N，arr中的值不是0就是1  arr[i]表示第i盏灯的状态，0代表灭灯，1代表亮灯  每一栈灯都有开关，但是按下i号灯的开关，会同时改变i-1、i、i+2栈灯的状态   问题一：  如果N盏灯排成一条直线,请问最少按下多少次开关,能让灯都亮起来  排成一条直线说明：  i为中间位置时，i号灯的开关能影响i-1、i和i+1  0号灯的开关只能影响0和1位置的灯  N-1号灯的开关只能影响N-2和N-1位置的灯    问题二：  如果N盏灯排成一个圈,请问最少按下多少次开关,能让灯都亮起来  排成一个圈说明：  i为中间位置时，i号灯的开关能影响i-1、i和i+1  0号灯的开关能影响N-1、0和1位置的灯  N-1号灯的开关能影响N-2、N-1和0位置的灯
●	301.删除无效的括号
 #Hard  #LeetCode  #大厂刷题班08
●	给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。 返回所有可能的结果。答案可以按 任意顺序 返回。
●	300.最长递增子序列
#大厂刷题班09  #Medium   #LeetCode
●	给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。  示例 1： ``` 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 输入：nums = [0,1,0,3,2,3] 输出：4 示例 3： 输入：nums = [7,7,7,7,7,7,7] 输出：1  ``` 提示： 1 <= nums.length <= 2500 -104 <= nums[i] <= 104   进阶： 你可以设计时间复杂度为 O(n2) 的解决方案吗？ 你能将算法的时间复杂度降低到 O(n log(n)) 吗?
●	354.俄罗斯套娃信封问题
#大厂刷题班09    #LeetCode   #Hard  #最长递增子序列
●	给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 注意：不允许旋转信封。  示例 1： ``` 输入：envelopes = [[5,4],[6,4],[6,7],[2,3]] 输出：3 解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。 示例 2： 输入：envelopes = [[1,1],[1,1],[1,1]] 输出：1  ``` 提示： 1 <= envelopes.length <= 5000 envelopes[i].length == 2 1 <= wi, hi <= 104
●	给你一批信封，返回最大的嵌套层数
●	每个信封都有长和宽两个维度的数据，A信封如果想套在B信封里面，A信封必须在长和宽上都小于B信封才行。 如果给你一批信封，返回最大的嵌套层数
●	45.跳跃游戏 II
 #LeetCode   #Hard #大厂刷题班10
●	给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 假设你总是可以到达数组的最后一个位置。  ``` 示例 1: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 示例 2: 输入: [2,3,0,1,4] 输出: 2 ``` 提示: 1 <= nums.length <= 1000 0 <= nums[i] <= 10^5
●	550.最常使用的K个单词II
 #LintCode   #Hard #大厂刷题班10 #加强堆
●	描述 在实时数据流中找到最常使用的k个单词. 实现TopK类中的三个方法: TopK(k), 构造方法 add(word), 增加一个新单词 topk(), 得到当前最常使用的k个单词. 如果两个单词有相同的使用频率, 按字典序排名. ``` 样例 ```text 样例 1: 输入： TopK(2) add("lint") add("code") add("code") topk() 输出：["code", "lint"] 解释： "code" 出现两次并且 "lint" 出现一次， 它们是出现最频繁的两个单词。 样例 2: 输入： TopK(1) add("aa") add("ab") topk() 输出：["aa"] 解释： "aa" 和 "ab" 出现 , 但是aa的字典序小于ab。 ```
●	629.K个逆序对数组
 #LeetCode   #Hard #大厂刷题班10
●	给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。 逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。 由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。 示例 1: ``` 输入: n = 3, k = 0 输出: 1 解释:  只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。 示例 2: 输入: n = 3, k = 1 输出: 2 解释:  数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。 ``` 说明:  n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。
●	426.将二叉搜索树转化为排序的双向链表
 #LeetCode   #大厂刷题班10  #Medium #二叉树递归套路
●	将一个 二叉搜索树 就地转化为一个 已排序的双向循环链表 。 对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 特别地，我们希望可以 就地 完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。  ``` 示例 1： 输入：root = [4,2,5,1,3]  ```
 
●	 ``` 输出：[1,2,3,4,5] 解释：下图显示了转化后的二叉搜索树，实线表示后继关系，虚线表示前驱关系。 ```
 
●	 ``` 示例 2： 输入：root = [2,1,3] 输出：[1,2,3] 示例 3： 输入：root = [] 输出：[] 解释：输入是空树，所以输出也是空链表。 示例 4： 输入：root = [1] 输出：[1] ``` 提示： -1000 <= Node.val <= 1000   Node.left.val < Node.val < Node.right.val    Node.val 的所有值都是独一无二的    0 <= Number of Nodes <= 2000
●	面试题 08.14.布尔运算
 #LeetCode   #Hard #大厂刷题班10 #范围上尝试的模型
●	给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、& (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。 ``` 示例 1: 输入: s = "1^0|0|1", result = 0 输出: 2 解释: 两种可能的括号方法是 1^(0|(0|1)) 1^((0|0)|1) 示例 2: 输入: s = "0&0&0&1^1|0", result = 1 输出: 10 ``` 提示： 运算符的数量不超过 19 个
●	1312.让字符串成为回文串的最少插入次数
#LeetCode   #Hard #大厂刷题班11 #范围上尝试的模型
●	问题一：一个字符串至少需要添加多少个字符能整体变成回文串 问题二：返回问题一的其中一种添加结果 问题三：返回问题一的所有添加结果 --- 给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。 请你返回让 s 成为回文串的 最少操作次数 。 「回文串」是正读和反读都相同的字符串。  ``` 示例 1： 输入：s = "zzazz" 输出：0 解释：字符串 "zzazz" 已经是回文串了，所以不需要做任何插入操作。 示例 2： 输入：s = "mbadm" 输出：2 解释：字符串可变为 "mbdadbm" 或者 "mdbabdm" 。 示例 3： 输入：s = "leetcode" 输出：5 解释：插入 5 个字符后字符串变为 "leetcodocteel" 。 示例 4： 输入：s = "g" 输出：0 示例 5： 输入：s = "no" 输出：1 ``` 提示： 1 <= s.length <= 500 s 中所有字符都是小写字母。
●	132.分割回文串 II
#LeetCode   #Hard #大厂刷题班11 #从左往右尝试的模型
●	问题一：一个字符串至少要切几刀能让切出来的子串都是回文串 问题二：返回问题一的其中一种划分结果 问题三：返回问题一的所有划分结果 --- 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。 返回符合要求的 最少分割次数 。  ``` 示例 1： 输入：s = "aab" 输出：1 解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。 示例 2： 输入：s = "a" 输出：0 示例 3： 输入：s = "ab" 输出：1 ``` 提示： 1 <= s.length <= 2000 s 仅由小写英文字母组成
●	567. 字符串的排列|字符串str中是否有某个子串是可以由字符串aim构成
 #LeetCode   #Hard #大厂刷题班12   #LeetCode    #Medium
●	给定长度为m的字符串aim，以及一个长度为n的字符串str 问能否在str中找到一个长度为m的连续子串， 使得这个子串刚好由aim的m个字符组成，顺序无所谓， 返回任意满足条件的一个子串的起始位置，未找到返回-1
●	ref:
●	字符串str中是否有某个子串是等于字符串match
#KMP
●	假设字符串str长度为N，字符串match长度为M，M <= N 想确定str中是否有某个子串是等于match的。 时间复杂度O(N)
●	在两个都有序的数组中找整体第K小的数
 #大厂刷题班12 #高频
●	两个等长有序数组求上中位数
#算法模型
●	二分, 能做到O(logN)
●	进阶问题： 在两个都有序的数组中找整体第K小的数 可以做到O(log(Min(M,N)))
●	4. 寻找两个正序数组的中位数
 #LeetCode #Hard
●	给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。  ``` 示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例 3： 输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例 4： 输入：nums1 = [], nums2 = [1] 输出：1.00000 示例 5： 输入：nums1 = [2], nums2 = [] 输出：2.00000 ``` 提示： nums1.length == m nums2.length == n 0 <= m <= 1000 0 <= n <= 1000 1 <= m + n <= 2000 -10^6 <= nums1[i], nums2[i] <= 10^6
●	128.最长连续序列
#大厂刷题班12   #Hard  #LeetCode
●	给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。  进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？   ``` 示例 1： 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 示例 2： 输入：nums = [0,3,7,2,5,8,4,6,0,1] 输出：9 ```  提示： 0 <= nums.length <= 10^4 -10^9 <= nums[i] <= 10^9
●	10.正则表达式匹配
#大厂刷题班12   #Hard  #LeetCode #斜率优化 #样本对应模型
●	卡牌游戏的获胜概率|21点游戏
#谷歌 #大厂刷题班13 #用代码模拟实验
●	有1-10数字的牌，可以有无限组 ，抽到每个数字等概率。规则是数字之和小于17可以再抽一次，等于或大于17而且小于21就赢了。如果抽到牌数字总和大于等于21就输了。最后求这个人赢的概率。
●	谷歌面试题扩展版 面值为1~N的牌组成一组， 每次你从组里等概率的抽出1~N中的一张 下次抽会换一个新的组，有无限组 当累加和<a时，你将一直抽牌 当累加和>=a且<b时，你将获胜 当累加和>=b时，你将失败 返回获胜的概率，给定的参数为N,a,b
●	87.扰乱字符串|玄变字符串
#大厂刷题班13   #Hard #LeetCode   #SuperHard #样本对应模型
●	给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。 下图是字符串 s1 = "great" 的一种可能的表示形式。 ```     great    /    \   gr    eat  / \    /  \ g   r  e   at            / \           a   t ``` 在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。 例如，如果我们挑选非叶节点 "gr" ，交换它的两个子节点，将会产生旋变/扰乱字符串 "rgeat" 。 ```     rgeat    /    \   rg    eat  / \    /  \ r   g  e   at            / \           a   t ```  我们将 "rgeat” 称作 "great" 的一个旋变/扰乱字符串。 同样地，如果我们继续交换节点 "eat" 和 "at" 的子节点，将会产生另一个新的旋变/扰乱字符串 "rgtae" 。 ```     rgtae    /    \   rg    tae  / \    /  \ r   g  ta  e        / \       t   a ``` 我们将 "rgtae” 称作 "great" 的一个旋变/扰乱字符串。 给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的旋变/扰乱字符串。 示例 1: ``` 输入: s1 = "great", s2 = "rgeat" 输出: true ``` 示例 2: ``` 输入: s1 = "abcde", s2 = "caebd" 输出: false ``` --- 使用下面描述的算法可以扰乱字符串 s 得到字符串 t ： 如果字符串的长度为 1 ，算法停止 如果字符串的长度 > 1 ，执行下述步骤： 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。 随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。 在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。 给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。  ``` 示例 1： 输入：s1 = "great", s2 = "rgeat" 输出：true 解释：s1 上可能发生的一种情形是： "great" --> "gr/eat" // 在一个随机下标处分割得到两个子字符串 "gr/eat" --> "gr/eat" // 随机决定：「保持这两个子字符串的顺序不变」 "gr/eat" --> "g/r / e/at" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割 "g/r / e/at" --> "r/g / e/at" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」 "r/g / e/at" --> "r/g / e/ a/t" // 继续递归执行此算法，将 "at" 分割得到 "a/t" "r/g / e/ a/t" --> "r/g / e/ a/t" // 随机决定：「保持这两个子字符串的顺序不变」 算法终止，结果字符串和 s2 相同，都是 "rgeat" 这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true 示例 2： 输入：s1 = "abcde", s2 = "caebd" 输出：false 示例 3： 输入：s1 = "a", s2 = "a" 输出：true ``` 提示： s1.length == s2.length 1 <= s1.length <= 30 s1 和 s2 由小写英文字母组成
●	517.超级洗衣机
#大厂刷题班13   #Hard  #LeetCode #硬记 #贪心 #阿里 #单点瓶颈
●	假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。 在每一步操作中，你可以选择任意 m （1 ≤ m ≤ n） 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。 给定一个非负整数数组代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的最少的操作步数。如果不能使每台洗衣机中衣物的数量相等，则返回 -1。  ``` 示例 1： 输入: [1,0,5] 输出: 3 解释:  第一步:    1     0 <-- 5    =>    1     1     4 第二步:    1 <-- 1 <-- 4    =>    2     1     3     第三步:    2     1 <-- 3    =>    2     2     2    示例 2： 输入: [0,3,0] 输出: 2 解释:  第一步:    0 <-- 3     0    =>    1     2     0     第二步:    1     2 --> 0    =>    1     1     1      示例 3: 输入: [0,2,0] 输出: -1 解释:  不可能让所有三个洗衣机同时剩下相同数量的衣物。 ``` 提示： n 的范围是 [1, 10000]。 在每台超级洗衣机中，衣物数量的范围是 [0, 1e5]。
●	ref:
●	使每个打包机器上的物品数量相等需要搬动的最小轮数
#硬记
●	有n个打包机器从左到右一字排开，上方有一个自动装置会抓取一批放物品到每个打 包机上，放到每个机器上的这些物品数量有多有少，由于物品数量不相同，需要工人 将每个机器上的物品进行移动从而到达物品数量相等才能打包。每个物品重量太大、 每次只能搬一个物品进行移动，为了省力，只在相邻的机器上移动。请计算在搬动最 小轮数的前提下，使每个机器上的物品数量相等。如果不能使每个机器上的物品相同， 返回-1。 例如[1,0,5]表示有3个机器，每个机器上分别有1、0、5个物品，经过这些轮后:      第一轮:1    0 <- 5 => 1 1 4 第二轮:1 <- 1 <- 4 => 2 1 3 第三轮:2    1 <- 3 => 2 2 2  移动了3轮，每个机器上的物品相等，所以返回3   例如[2,2,3]表示有3个机器，每个机器上分别有2、2、3个物品， 这些物品不管怎么移动，都不能使三个机器上物品数量相等，返回-1
●	803.打砖块
 #LeetCode   #Hard #大厂刷题班13 #并查集
●	有一个 m x n 的二元网格，其中 1 表示砖块，0 表示空白。砖块 稳定（不会掉落）的前提是： 一块砖直接连接到网格的顶部，或者 至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时 给你一个数组 hits ，这是需要依次消除砖块的位置。每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。 返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目。 注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。  ``` 示例 1： 输入：grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]] 输出：[2] 解释： 网格开始为： [[1,0,0,0]，  [1,1,1,0]] 消除 (1,0) 处加粗的砖块，得到网格： [[1,0,0,0]  [0,1,1,0]] 两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格： [[1,0,0,0],  [0,0,0,0]] 因此，结果为 [2] 。 示例 2： 输入：grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]] 输出：[0,0] 解释： 网格开始为： [[1,0,0,0],  [1,1,0,0]] 消除 (1,1) 处加粗的砖块，得到网格： [[1,0,0,0],  [1,0,0,0]] 剩下的砖都很稳定，所以不会掉落。网格保持不变： [[1,0,0,0],   [1,0,0,0]] 接下来消除 (1,0) 处加粗的砖块，得到网格： [[1,0,0,0],  [0,0,0,0]] 剩下的砖块仍然是稳定的，所以不会有砖块掉落。 因此，结果为 [0,0] 。 ``` 提示： m == grid.length n == grid[i].length 1 <= m, n <= 200 grid[i][j] 为 0 或 1 1 <= hits.length <= 4 * 10^4 hits[i].length == 2 0 <= xi <= m - 1 0 <= yi <= n - 1 所有 (xi, yi) 互不相同
●	ref:
●	粘在天花板上的数字与炸弹
#并查集
●	给定一个只含0和1二维数组matrix，第0行表示天花板。每个位置认为与上、下、左、右四个方向有粘性，比如：   matrix =    1 0 0 1 0   1 0 0 1 1   1 1 0 1 1   1 0 0 0 0   0 0 1 1 0   注意到0行0列是1，然后能延伸出5个1的一片。同理0行3列也是1，也能延伸出5个1的一片。注意到4行2列是1，然后能延伸出2个1的一片。其中有两片1是粘在天花板上的，而4行2列延伸出来的这片，认为粘不住就掉下来了。   在给定一个二维数组bomb，表示炸弹的位置，比如：   bomb =    2 0   1 3   1 4   0 3   第一枚炮弹在2行0列，该处的1直接被打碎，然后会有2个1掉下来。   第二枚炮弹在1行3列，该处的1直接被打碎，不会有1掉下来，因为这一片1还能粘在一起。   第三枚炮弹在1行4列，该处的1直接被打碎，然后会有2个1掉下来。   第四枚炮弹在0行3列，该处的1直接被打碎，不会有1掉下来，因为这一片1只剩这一个了。   根据matrix和bomb，返回结果[2,3,0,0]。
●	32.最长的有效括号子串长度
#大厂刷题班14  #Hard  #LeetCode #动态规划
●	括号有效配对是指：    1）任何一个左括号都能找到和其正确配对的右括号    2）任何一个右括号都能找到和其正确配对的左括号    返回一个括号字符串中，最长的括号有效子串的长度
●	给定一个只由左括号和右括号的字符串, 返回最长的有效括号子串的长度
●	32.最长有效括号
●	给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。   ``` 示例 1： 输入：s = "(()" 输出：2 解释：最长有效括号子串是 "()" 示例 2： 输入：s = ")()())" 输出：4 解释：最长有效括号子串是 "()()" 示例 3： 输入：s = "" 输出：0 ``` 提示： 0 <= s.length <= 3 * 10^4   s[i] 为 '(' 或 ')'
●	小于等于K的最大子数组累加和
#大厂刷题班14 #有序表
●	请返回arr中，求子数组的累加和，是<=K的并且是最大的 返回这个最大的累加和
●	求完全二叉树节点的个数
#大厂刷题班14 #二叉树的递归套路
●	给定一个棵完全二叉树，返回这棵树的节点个数，要求时间复杂度小于O(树的节点数)
●	41.缺失的第一个正数
#大厂刷题班14   #Hard  #LeetCode
●	给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。  ``` 示例 1： 输入：nums = [1,2,0] 输出：3 示例 2： 输入：nums = [3,4,-1,1] 输出：2 示例 3： 输入：nums = [7,8,9,11,12] 输出：1 ``` 提示： 1 <= nums.length <= 5 * 10^5 -2^31 <= nums[i] <= 2^31 - 1
●	无需数组, 有正, 负, 零, >K的情况下哪个正整数缺失且最小 把所有数减个K就是一个题
#字节
●	99.恢复二叉搜索树
#大厂刷题班14   #Hard  #LeetCode
●	给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。 进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？  ``` 示例 1： 输入：root = [1,3,null,null,2] 输出：[3,1,null,null,2] 解释：3 不能是 1 左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。 示例 2： 输入：root = [3,1,4,null,null,2] 输出：[2,1,4,null,null,3] 解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。 ``` 提示： 树上节点的数目在范围 [2, 1000] 内 -2^31 <= Node.val <= 2^31 - 1
●	搜索二叉树上最大子拓扑结构的节点数
#大厂刷题班14  #谷歌 #二叉树的递归套路
●	从二叉树的某个节点x开始，往下子节点都要的，叫子树； 在二叉树上只要能连起来的任何结构，叫子拓扑结构； 返回二叉树上满足搜索二叉树性质的、最大子拓扑结构的节点数
●	121.买卖股票的最佳时机
#大厂刷题班15 #LeetCode  #Easy
●	122.买卖股票的最佳时机 II
#大厂刷题班15 #LeetCode  #Easy
●	123.买卖股票的最佳时机 III
#大厂刷题班15 #LeetCode  #Easy
●	给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。  ``` 示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。         注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。         因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3： 输入：prices = [7,6,4,3,1]  输出：0  解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 示例 4： 输入：prices = [1] 输出：0 ``` 提示： 1 <= prices.length <= 10^5 0 <= prices[i] <= 10^5
●	188.买卖股票的最佳时机 IV
#大厂刷题班15 #LeetCode   #Hard
●	给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。  ``` 示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。      随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 ``` 提示： 0 <= k <= 100 0 <= prices.length <= 1000 0 <= prices[i] <= 1000
●	309.最佳买卖股票时机含冷冻期
#大厂刷题班15 #LeetCode  #Medium
●	给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 ``` 示例: 输入: [1,2,3,0,2] 输出: 3  解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] ```
●	714.买卖股票的最佳时机含手续费
#大厂刷题班15 #LeetCode  #Medium
●	给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 ``` 示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8 解释: 能够达到的最大利润:   在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. ``` 注意: 0 < prices.length <= 50000. 0 < prices[i] < 50000. 0 <= fee < 50000.
●	数组的子集能否累加出K
#大厂刷题班16
●	给定一个有正、有负、有0的数组arr， 给定一个整数k， 返回arr的子集是否能累加出k 1）正常怎么做？ 2）如果arr中的数值很大，但是arr的长度不大，怎么做？
●	数组的子集不能累加出的最小正数
#大厂刷题班16
●	给定一个正数数组arr， 返回arr的子集不能累加出的最小正数 1）正常怎么做？ 2）如果arr中肯定有1这个值，怎么做？
●	330.按要求补齐数组
#大厂刷题班16  #LeetCode   #Hard
●	给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。 ``` 示例 1: 输入: nums = [1,3], n = 6 输出: 1  解释: 根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。 现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。 其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。 所以我们最少需要添加一个数字。 示例 2: 输入: nums = [1,5,10], n = 20 输出: 2 解释: 我们需要添加 [2, 4]。 示例 3: 输入: nums = [1,2,2], n = 5 输出: 0 ```
●	336.寻找回文串
#大厂刷题班16   #Hard  #LeetCode
●	给定字符串数组words，其中所有字符串都不同，如果words[i]+words[j]是回文串就记 录(i,j)，找到所有记录并返回 例子一: 输入：["abcd","dcba","lls","s","sssll"] 输出：[[0,1],[1,0],[3,2],[2,4]] 解释：输出的每一组数组，两个下标代表字符串拼接在一起，都是回文串 abcddcba、 dcbaabcd 、 slls 、 llssssll
●	剑指 Offer 62. 圆圈中最后剩下的数字 | 约瑟夫环问题
#大厂刷题班16   #Easy  #LeetCode
●	给定一个链表头节点head，和一个正数m 从头开始，每次数到m就杀死当前节点 然后被杀节点的下一个节点从1开始重新数， 周而复始直到只剩一个节点，返回最后的节点
●	求数组调整之后的逆序对数量
#大厂刷题班16   #Hard  #腾讯
●	给定整数power，给定一个数组arr，给定一个数组reverse。 含义如下： arr的长度一定是2的power次方， reverse中的每个值一定都在0~power范围。 例如power = 2, arr = {3, 1, 4, 2}，reverse = {0, 1, 0, 2} 任何一个在前的数字可以和任何一个在后的数组，构成一对数。 可能是升序关系、相等关系或者降序关系。 arr开始时有如下的降序对：(3,1)、(3,2)、(4,2)，一共3个。 接下来根据reverse对arr进行调整： reverse[0] = 0, 表示在arr中，划分每1(2的0次方)个数一组，然后每个小组内部逆序， 那么arr变成[3,1,4,2]，此时有3个逆序对  reverse[1] = 1, 表示在arr中，划分每2(2的1次方)个数一组，然后每个小组内部逆序， 那么arr变成[1,3,2,4]，此时有1个逆序对 reverse[2] = 0, 表示在arr中，划分每1(2的0次方)个数一组，然后每个小组内部逆序， 那么arr变成[1,3,2,4]，此时有1个逆序对。 reverse[3] = 2, 表示在arr中，划分每4(2的2次方)个数一组，然后每个小组内部逆序， 那么arr变成[4,2,3,1]，此时有4个逆序对。 所以返回[3,1,1,4]，表示每次调整之后的逆序对数量。 输入数据状况： power的范围[0,20] arr长度范围[1,10的7次方] reverse长度范围[1,10的6次方]
●	240. 搜索二维矩阵 II | 行列递增矩阵的查找
#大厂刷题班17  #LeetCode   #Medium
●	给定一个每一行有序、每一列也有序，整体可能无序的二维数组 再给定一个数num， 返回二维数组中有没有num这个数 在行也有序、列也有序的二维数组中，找num，找到返回true，否则false
●	240.搜索二维矩阵 II
●	编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。  ``` 示例 1： 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 输出：true ```
 
●	``` 示例 2： 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20 输出：false ```
 
●	提示： m == matrix.length n == matrix[i].length 1 <= n, m <= 300 -10^9 <= matix[i][j] <= 10^9 每行的所有元素从左到右升序排列 每列的所有元素从上到下升序排列 -10^9 <= target <= 10^9
●	378.行列递增矩阵中的第K小
#大厂刷题班17  #LeetCode   #Medium #二分法
●	给定一个每一行有序、每一列也有序，整体可能无序的二维数组 在给定一个正数k， 返回二维数组中，最小的第k个数
●	子序列中字面值等于字符串T的个数
#大厂刷题班17 #样本对应模型
●	给定两个字符串S和T 返回S的所有子序列中 有多少个子序列的字面值等于T
●	给定两个字符串S和T，返回S子序列等于T的不同子序列个数?
●	940.不同的子序列 II
#大厂刷题班17  #Hard  #LeetCode #从左往右尝试的模型
●	给定一个字符串s，求s中有多少个字面值不相同的子序列。 --- 给定一个字符串 S，计算 S 的不同非空子序列的个数。 因为结果可能很大，所以返回答案模 10^9 + 7.  ``` 示例 1： 输入："abc" 输出：7 解释：7 个不同的子序列分别是 "a", "b", "c", "ab", "ac", "bc", 以及 "abc"。 示例 2： 输入："aba" 输出：6 解释：6 个不同的子序列分别是 "a", "b", "ab", "ba", "aa" 以及 "aba"。 示例 3： 输入："aaa" 输出：3 解释：3 个不同的子序列分别是 "a", "aa" 以及 "aaa"。 ```  提示： S 只包含小写字母。 1 <= S.length <= 2000
●	汉诺塔游戏中的最优状态
#大厂刷题班18
●	给定一个数组arr，长度为N，arr中的值只有1，2，3三种 arr[i] == 1，代表汉诺塔问题中，从上往下第i个圆盘目前在左 arr[i] == 2，代表汉诺塔问题中，从上往下第i个圆盘目前在中 arr[i] == 3，代表汉诺塔问题中，从上往下第i个圆盘目前在右 那么arr整体就代表汉诺塔游戏过程中的一个状况 如果这个状况不是汉诺塔最优解运动过程中的状况，返回-1 如果这个状况是汉诺塔最优解运动过程中的状况，返回它是第几个状况
●	934.最短的桥
#大厂刷题班18 #Medium  #LeetCode
●	在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。） 现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。 返回必须翻转的 0 的最小数目。（可以保证答案至少是 1 。）  ``` 示例 1： 输入：A = [[0,1],[1,0]] 输出：1 示例 2： 输入：A = [[0,1,0],[0,0,0],[0,0,1]] 输出：2 示例 3： 输入：A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] 输出：1 ``` 提示： 2 <= A.length == A[0].length <= 100 A[i][j] == 0 或 A[i][j] == 1
●	最大路径和
#大厂刷题班18 #牛客
●	给定一个矩阵matrix，先从左上角开始，每一步只能往右或者往下走，走到右下角。然后从右下角出发，每一步只能往上或者往左走，再回到左上角。任何一个位置的数字，只能获得一遍。返回最大路径和。  ```text 输入描述: 第一行输入两个整数M和N，M,N<=200 接下来M行，每行N个整数，表示矩阵中元素 输出描述: 输出一个整数，表示最大路径和    示例1 输入 5 10 1 1 1 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 输出 16 示例2 输入 5 10 1 1 1 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 0 1 0 0 0 1 0 0 0 0 0 1 1 1 1 0 1 输出 15 ``` leetcode714.[[摘樱桃]]和牛客网上的输入规定不同    leetcode上，输入一定保证正方形, 牛客网上，可以是长方形
●	两个有序数组间相加和的Topk问题
#大厂刷题班18 #牛客 #大根堆
●	描述 给定两个有序数组 arr1 和 arr2，再给定一个整数 k，返回来自 arr1 和 arr2 的两个数相加和最大的前 k 个，两个数必须分别来自两个数组, 按照降序输出 [要求] 时间复杂度为O(klogk) 输入描述： 第一行三个整数 N, K 分别表示数组 arr1, arr2 的大小，以及需要询问的数 接下来一行 N 个整数，表示 arr1 内的元素 再接下来一行 N 个整数，表示 arr2 内的元素 输出描述： 输出 K 个整数表示答案 ``` 示例 1 输入： 5 4 1 2 3 4 5 3 5 7 9 11 输出： 16 15 14 14 ``` 备注: 1<=N<=10^5 0<<arr1i, arr2i<=10^9 保证 1<=K<=2N
●	146.LRU内存替换算法的实现
#大厂刷题班18 #Medium  #LeetCode
●	运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。 实现 LRUCache 类： LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。  进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？ ``` 示例： 输入 ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] 输出 [null, null, null, 1, null, -1, null, -1, 3, 4] 解释 LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // 缓存是 {1=1} lRUCache.put(2, 2); // 缓存是 {1=1, 2=2} lRUCache.get(1);    // 返回 1 lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3} lRUCache.get(2);    // 返回 -1 (未找到) lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3} lRUCache.get(1);    // 返回 -1 (未找到) lRUCache.get(3);    // 返回 3 ``` 提示： 1 <= capacity <= 3000 0 <= key <= 3000 0 <= value <= 10^4 最多调用 3 * 10^4 次 get 和 put
●	LFU内存替换算法的实现|460.LFU 缓存
#大厂刷题班19  #Hard
●	一个缓存结构需要实现如下功能   ```text void set(int key, int value): 加入或修改key对应的value int get(int key)            : 查询key对应的value值 ``` 但是缓存中最多放K条记录，如果新的第K+1条记录要加入，就需要根据策略删掉一条记录，然后才能把新记录加入。    这个策略为:   在缓存结构的K条记录中，哪一个key从进入缓存结构的时刻开始，被调用set或者get的次数最少，就删掉这个key的记录;   如果调用次数最少的key有多个，上次调用发生最早的key被删除。   这就是LFU缓存替换算法。实现这个结构，K作为参数给出。
●	460.LFU 缓存
 #Hard  #LeetCode
●	请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。 实现 LFUCache 类： LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象 int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。 void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。 注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。 为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。  当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。 ``` 示例： 输入： ["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]] 输出： [null, null, null, 1, null, -1, 3, null, -1, 3, 4] 解释： // cnt(x) = 键 x 的使用计数 // cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的） LFUCache lFUCache = new LFUCache(2); lFUCache.put(1, 1);   // cache=[1,_], cnt(1)=1 lFUCache.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1 lFUCache.get(1);      // 返回 1                       // cache=[1,2], cnt(2)=1, cnt(1)=2 lFUCache.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小                       // cache=[3,1], cnt(3)=1, cnt(1)=2 lFUCache.get(2);      // 返回 -1（未找到） lFUCache.get(3);      // 返回 3                       // cache=[3,1], cnt(3)=2, cnt(1)=2 lFUCache.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用                       // cache=[4,3], cnt(4)=1, cnt(3)=2 lFUCache.get(1);      // 返回 -1（未找到） lFUCache.get(3);      // 返回 3                       // cache=[3,4], cnt(4)=1, cnt(3)=3 lFUCache.get(4);      // 返回 4                       // cache=[3,4], cnt(4)=2, cnt(3)=3 ``` 提示： 0 <= capacity, key, value <= 10^4 最多调用 10^5 次 get 和 put 方法  进阶：你可以为这两种操作设计时间复杂度为 O(1) 的实现吗？
●	1~N中所有数字包含1的个数
#大厂刷题班19 #数位DP
●	给定一个正数N，比如N = 13，在纸上把所有数都列出来如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 可以数出1这个字符出现了6次 给定一个正数N，如果把1~N都列出来， 返回1这个字符出现的多少次
●	632.最小区间
#大厂刷题班19  #LeetCode   #Hard  #谷歌
●	你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。 我们定义如果 b-a < d-c 或者在 b-a == d-c 时 a < c，则区间 [a,b] 比 [c,d] 小。 示例 1: ```text 输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] 输出: [20,24] 解释:  列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。 列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。 列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。 ``` 注意: 1. 给定的列表可能包含重复元素，所以在这里升序表示 >= 。 2. 1<= k <= 3500 3. -10^5 <= 元素的值 <= 10^5 4. 对于使用Java的用户，请注意传入类型已修改为List<List<Integer>>。重置代码模板后可以看到这项改动。 提示：   nums.length == k 1 <= k <= 3500 1 <= nums[i].length <= 50 -10^5 <= nums[i][j] <= 10^5 nums[i] 按非递减顺序排列
●	扑克牌问题
#大厂刷题班19 #根据数据量猜解法 #看菜下饭
●	一张扑克有3个属性， 每种属性有3种值(A、B、C) 比如"AAA",第一个属性值A,第二个属性值A，第三个属性值A 比如"BCA",第一个属性值B，第二个属性值C，第三个属性值A 给定一个字符串类型的数组cards口，每一个字符串代表一张扑克 从中挑选三张扑克，每种属性达标的条件是:这个属性在三张扑克中全一样，或全不一样 挑选的三张扑克达标的要求是:每种属性都满足上面的条件 比如: "ABC"、 "CBC"、"BBC" 第一张第一个属性为"A"、第二张第一个属性为"C"、第三张第一个属性为"B"，全不一样 第一-张第二个属性为"B"、第二张第二个属性为"B”、第三张第二个属性为"B"，全样 第一张第三个属性为"C"、第二张第三个属性为"C"、第三张第三个属性为"C",全一样 每种属性都满足在三张扑克中全一样，或全不一样，所以这三张扑克达标 返回在cards口中任意挑选三张扑克，达标的方法数
●	已知中序遍历数组和先序遍历数组，返回后序遍历数组
#大厂刷题班20
●	如果只给定一个二叉树前序遍历数组pre和中序遍历数组in， 能否不重建树，而直接生成这个二叉树的后序数组并返回 已知二叉树中没有重复值
●	952. 按公因数计算最大组件大小
#LeetCode #Hard #大厂刷题班20
●	给定一个由不同正整数的组成的非空数组 A，考虑下面的图： 有 A.length 个节点，按从 A[0] 到 A[A.length - 1] 标记； 只有当 A[i] 和 A[j] 共用一个大于 1 的公因数时，A[i] 和 A[j] 之间才有一条边。 返回图中最大连通组件的大小。  ``` 示例 1： 输入：[4,6,15,35] 输出：4 ```
 
●	 ``` 示例 2： 输入：[20,50,9,63] 输出：2 ```
 
●	``` 示例 3： 输入：[2,3,6,7,4,12,21,39] 输出：8 ```
 
●	提示： 1 <= A.length <= 20000 1 <= A[i] <= 100000
●	字符串的回文子序列
#大厂刷题班20 #范围上的尝试模型
●	给定一个字符串str，当然可以生成很多子序列 返回有多少个子序列是回文子序列，空序列不算回文 比如，str = “aba” 回文子序列：{a}、{a}、 {a,a}、 {b}、{a,b,a} 返回5
●	将长度为2N数组的前半跟后半数组每个数交替
#下标循环怼  #完美洗牌问题 #大厂刷题班20
●	给定一个长度为偶数的数组arr，假设长度为N*2 左部分：arr[L1……Ln]                  右部分： arr[R1……Rn]    请把arr调整成arr[L1,R1,L2,R2,L3,R3,…,Ln,Rn]       要求：时间复杂度O(N)，额外空间复杂度O(1)
●	ref: 324. 摆动排序 II
 #LeetCode   #Medium
●	原题不限制额外空间复杂度
●	Followup: O(1), Hard, 完美洗牌解决
●	树链剖分
#大厂刷题班21
●	689. 三个无重叠子数组的最大和
 #LeetCode   #Hard #大厂刷题班22
●	给定数组 nums 由正整数组成，找到三个互不重叠的子数组的最大和。 每个子数组的长度为k，我们要使这3* k个项的和最大化。 返回每个区间起始索引的列表（索引从 0 开始）。如果有多个结果，返回字典序最小的一个。 ``` 示例: 输入: [1,2,1,2,6,7,5,1], 2 输出: [0, 3, 5] 解释: 子数组 [1, 2], [2, 6], [7, 5] 对应的起始索引为 [0, 3, 5]。 我们也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。 ``` 注意: nums.length的范围在[1, 20000]之间。 nums[i]的范围在[1, 65535]之间。 k的范围在[1, floor(nums.length / 3)]之间。
●	42. 接雨水
 #LeetCode   #Hard #大厂刷题班22
●	给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
 
●	``` 示例 1： 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。  示例 2： 输入：height = [4,2,0,3,2,5] 输出：9 ``` 提示： n == height.length 0 <= n <= 3 * 10^4 0 <= height[i] <= 10^5
●	407. 接雨水 II
 #LeetCode   #Hard #大厂刷题班22
●	给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。   示例： 给出如下 3x6 的高度图: [   [1,4,3,1,3,2],   [3,2,1,3,2,4],   [2,3,3,2,3,1] ] 返回 4 。
 
●	如上图所示，这是下雨前的高度图 [[1,4,3,1,3,2],  [3,2,1,3,2,4],  [2,3,3,2,3,1]] 的状态。 下雨后，雨水将会被存储在这些方块中。总的接雨水量是4。 提示： 1 <= m, n <= 110 0 <= heightMap[i][j] <= 20000。
 
●	能够互相看见环形山的对数
#单调栈 #大厂刷题班22
●	一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度。比如， {3,1,2,4,5}、{4,5,3,1,2}或{1,2,4,5,3}都代表同样结构的环形山。 山峰A和山峰B能够相互看见的条件为: 1.如果A和B是同一座山，认为不能相互看见。 2.如果A和B是不同的山，并且在环中相邻，认为可以相互看见。 3.如果A和B是不同的山，并且在环中不相邻，假设两座山高度的最小值为min。   1)如果A通过顺时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互 看见    2)如果A通过逆时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互 看见    3)两个方向只要有一个能看见，就算A和B可以相互看见 给定一个不含有负数且没有重复值的数组 arr，请返回有多少对山峰能够相互看见。    进阶: 给定一个不含有负数但可能含有重复值的数组arr，返回有多少对山峰能够相互看见。   进阶问题 给定一个不含有负数但可能含有重复值的数组arr，返回有多少对山峰能够相互看见。
●	956. 最高的广告牌
#LeetCode  #Hard #大厂刷题班22
●	你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。 你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。 返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。  ``` 示例 1： 输入：[1,2,3,6] 输出：6 解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。 示例 2： 输入：[1,2,3,4,5,6] 输出：10 解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。 示例 3： 输入：[1,2] 输出：0 解释：没法安装广告牌，所以返回 0。 ``` 提示： 0 <= rods.length <= 20 1 <= rods[i] <= 1000 钢筋的长度总和最多为 5000
●	找出最大的左部分最大值减去右部分最大值的绝对值
 #大厂刷题班23
●	给定一个数组arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分，剩下的 作为右部分。但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的， 左部分最大值减去右部分最大值的绝对值。但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的， 左部分最大值减去右部分最大值的绝对值。
●	最大可整合子数组的长度
 #大厂刷题班23
●	定义什么是可整合数组： 一个数组排完序之后，除了最左侧的数外，有arr[i] = arr[i-1]+1 则称这个数组为可整合数组比如{5,1,2,4,3}、{6,2,3,1,5,4}都是可整合数组比如{5,1,2,4,3}、{6,2,3,1,5,4}都是可整合数组 返回arr中最长可整合子数组的长度
●	超级水王问题
 #大厂刷题班23 #摩尔投票
●	扩展1：摩尔投票
●	扩展2：给定一个正数K，返回所有出现次数>N/K的数
●	169. 多数元素
 #LeetCode   #Easy
●	给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
●	229. 求众数 II
 #LeetCode   #Medium
●	给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。 进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。
●	1000. 合并石头的最低成本
 #LeetCode   #Hard #大厂刷题班23
●	有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。  `````` 示例 1： 输入：stones = [3,2,4,1], K = 2输出：20输出：20 解释： 从 [3, 2, 4, 1] 开始。 合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。 合并 [4, 1]，成本为 5，剩下 [5, 5]。 合并 [5, 5]，成本为 10，剩下 [10]。 总成本 20，这是可能的最小值。示例 2： 输入：stones = [3,2,4,1], K = 3 输出：-1 解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。. 示例 3： 输入：stones = [3,5,1,2,6], K = 3 输出：25 解释： 从 [3, 5, 1, 2, 6] 开始。合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。 合并 [3, 8, 6]，成本为 17，剩下 [17]。 总成本 25，这是可能的最小值。 ``` 提示： 1 <= stones.length <= 30 2 <= K <= 30 1 <= stones[i] <= 100
●	二叉树节点间最近公共祖先的批量查询问题
#并查集 #Tarjan   #Hard #大厂刷题班23 #最近公共祖先
●	如下的Node类是标准的二叉树节点的结构: ```java public class Node {     public int value;     public node left;     public node right;     public Node(int data) {         this.value = data;     } } ``` 在定义Query类如下: ```java public class Query {     public Node o1;     public Node o2;     public Query(Node o1, Node o2) {         this.o1 = o1;         this.o2 = o2;     } } ``` 一个 Query 类的实例表示一条查询语句，表示想要查询 o1 节点和 o2 节点的最近公共 祖先 节点。 给定一棵二叉树的头节点 head，并给定所有的查询语句，即一个 Query 类型的数组 Query[] ques，请返回Node类型的数组Node[] ans，ans[i]代表ques[i]这条查询的答案， 即ques[i].o1和 ques[i].o2 的最近公共祖先。 【要求】 如果二叉树的节点数为 N，查询语句的条数为 M，整个处理过程的时间复杂度要求达到 O(N+M)。
●	数组能不能分成4个相等的部分
#预处理数组 #大厂刷题班24
●	给定一个数组arr，长度一定大于6 一定要选3个数字做分割点，从而分出4个部分，并且每部分都有数分割点的数字直接删除，不属于任何4个部分中的任何一个。分割点的数字直接删除，不属于任何4个部分中的任何一个。返回有没有可能分出的4个部分累加和一样大返回有没有可能分出的4个部分累加和一样大 如：{3,2,3,7,4,4,3,1,1,6,7,1,5,2}可以分成{3,2,3}、{4,4}、{1,1,6}、{1,5,2}。分割点是不算的！可以分成{3,2,3}、{4,4}、{1,1,6}、{1,5,2}。分割点是不算的！
●	第k小的数值对
 #大厂刷题班24 #字节
●	长度为N的数组arr，一定可以组成N^2个数值对。例如arr = [3,1,2]，例如arr = [3,1,2]，数值对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)，数值对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)， 也就是任意两个数都有数值对，而且自己和自己也算数值对。 数值对怎么排序？规定，第一维数据从小到大，第一维数据一样的，第二维数组也从小到大。所以上面的数值对排序的结果为： (1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)    给定一个数组arr，和整数k，返回第k小的数值对。
●	吉祥里程表
 #大厂刷题班24 #字节
●	正常的里程表会依次显示自然数表示里程   吉祥的里程表会忽略含有4的数字而跳到下一个完全不含有4的数   正常：1 2 3 4 5 6 7 8   9 10 11 12 13 14 15  吉祥：1 2 3 5 6 7 8 9 10 11 12 13 15 16 17 ... 38 39 50 51 52 53 55   给定一个吉祥里程表的数字num，返回这个数字代表的真实里程  给定一个吉祥里程表的数字num，返回这个数字代表的真实里程
●	棋盘染色问题
#打表法  #大厂刷题班24
●	N * M的棋盘每种颜色的格子数必须相同的每种颜色的格子数必须相同的 上下左右的格子算相邻 相邻格子染的颜色必须不同 所有格子必须染色返回至少多少种颜色可以完成任务返回至少多少种颜色可以完成任务
●	最短包含子串
 #大厂刷题班24 #欠账表
●	给定两个字符串str1和str2在str1中寻找一个最短子串，能包含str2的所有字符在str1中寻找一个最短子串，能包含str2的所有字符 字符顺序无所谓，str1的这个最短子串也可以包含多余的字符返回这个最短包含子串返回这个最短包含子串 【举例】 str1="abcde"，str2="ac"因为"abc"包含 str2 所有的字符，并且在满足这一条件的str1的所有子串中，"abc"是 最短的，返回3。因为"abc"包含 str2 所有的字符，并且在满足这一条件的str1的所有子串中，"abc"是 最短的，返回3。str1="12345"，str2="344" 最小包含子串不存在，返回0。str1="12345"，str2="344" 最小包含子串不存在，返回0。
●	316. 去除重复字母
 #大厂刷题班24  #LeetCode   #Medium #贪心
●	给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。 需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 注意：该题与 1081.[[不同字符的最小子序列]]相同  ``` 示例 1： 输入：s = "bcabc" 输出："abc" 示例 2： 输入：s = "cbacdcbc" 输出："acdb" ``` 提示： 1 <= s.length <= 10^4   s 由小写英文字母组成
●	1081.不同字符的最小子序列
 #LeetCode   #Medium
●	返回 s 字典序最小的子序列，该子序列包含 s 的所有不同字符，且只包含一次。 注意：该题与 316.[[去除重复字母]]相同 ``` 示例 1： 输入：s = "bcabc" 输出："abc" 示例 2： 输入：s = "cbacdcbc" 输出："acdb" ``` 提示： 1 <= s.length <= 1000    s 由小写英文字母组成
●	751.IP 到 CIDR
 #LeetCode     #Medium    #大厂刷题班25
●	给定一个起始 IP 地址 ip 和一个我们需要包含的 IP 的数量 n，返回用列表（最小可能的长度）表示的 CIDR块的范围。  CIDR 块是包含 IP 的字符串，后接斜杠和固定长度。例如：“123.45.67.89/20”。固定长度 “20” 表示在特定的范围中公共前缀位的长度。 ``` 示例 1： 输入：ip = "255.0.0.7", n = 10 输出：["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"] 解释： 转换为二进制时，初始IP地址如下所示（为清晰起见添加了空格）： 255.0.0.7 -> 11111111 00000000 00000000 00000111 地址 "255.0.0.7/32" 表示与给定地址有相同的 32 位前缀的所有地址， 在这里只有这一个地址。 地址 "255.0.0.8/29" 表示与给定地址有相同的 29 位前缀的所有地址： 255.0.0.8 -> 11111111 00000000 00000000 00001000 有相同的 29 位前缀的地址如下： 11111111 00000000 00000000 00001000 11111111 00000000 00000000 00001001 11111111 00000000 00000000 00001010 11111111 00000000 00000000 00001011 11111111 00000000 00000000 00001100 11111111 00000000 00000000 00001101 11111111 00000000 00000000 00001110 11111111 00000000 00000000 00001111 地址 "255.0.0.16/32" 表示与给定地址有相同的 32 位前缀的所有地址， 这里只有 11111111 00000000 00000000 00010000。 总之，答案指定了从 255.0.0.7 开始的 10 个 IP 的范围。 有一些其他的表示方法，例如： ["255.0.0.7/32","255.0.0.8/30", "255.0.0.12/30", "255.0.0.16/32"], 但是我们的答案是最短可能的答案。 另外请注意以 "255.0.0.7/30" 开始的表示不正确， 因为其包括了 255.0.0.4 = 11111111 00000000 00000000 00000100 这样的地址， 超出了需要表示的范围。 ``` 注： ip 是有效的 IPv4 地址。 每一个隐含地址 ip + x (其中 x < n) 都是有效的 IPv4 地址。 n 为整数，范围为 [1, 1000]。
●	15.三数之和
 #LeetCode   #Medium   #大厂刷题班25
●	1.两数之和
 #LeetCode   #Easy
●	149.直线上最多的点数
 #LeetCode    #Hard   #大厂刷题班25
●	给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。
●	134.加油站
 #LeetCode     #Medium    #大厂刷题班25
●	三个有序数组中找三个数互减绝对值累加和的最小值
#有序表   #大厂刷题班26
●	给你三个有序数组, 在每个数组中分别拿出一个值, X, Y, Z, 问怎么选择这三个值让|X-Y| + |Y-Z| + |Z-X|的绝对值尽量小, 求这个最小值
●	ref:  632.最小区间
●	212. 单词搜索 II
 #LeetCode      #Hard  #大厂刷题班26 #前缀树  #递归练习 #Trie
●	小朋友排队的最高分数
#全排列  #大厂刷题班26
●	N个小朋友排队, 如果有一个小朋友比前一个小朋友身高要高加 1 分, 如果后一个小朋友比前一个小朋友体重要大加2 分, 如果后一个个小朋友比前一个小朋友身高跟体重都大加 5 分。每个小朋友给两维数据，一个是身高，一个是体重。请问N个小朋友如何排队得分最高。小朋友数量N=10
●	282.给表达式添加运算符
 #LeetCode      #Hard  #大厂刷题班26 #递归练习
●	给定一个仅包含数字 0-9 的字符串和一个目标值，在数字之间添加 二元  运算符（不是一元）+、- 或 * ，返回所有能够得到目标值的表达式。  ``` 示例 1: 输入: num = "123", target = 6 输出: ["1+2+3", "1*2*3"]  示例 2: 输入: num = "232", target = 8 输出: ["2*3+2", "2+3*2"] 示例 3: 输入: num = "105", target = 5 输出: ["1*0+5","10-5"] 示例 4: 输入: num = "00", target = 0 输出: ["0+0", "0-0", "0*0"] 示例 5: 输入: num = "3456237490", target = 9191 输出: [] ``` 提示： 0 <= num.length <= 10 num 仅含数字
●	126.单词接龙 II
 #LeetCode   #Hard   #大厂刷题班26 #深度优先遍历 #宽度优先遍历 #递归练习 #BFS #DFS
●	按字典 wordList 完成从单词 beginWord 到单词 endWord 转化， 一个表示此过程的 转换序列 是形式上像 beginWord -> s1 -> s2 -> ... -> sk 这样的单词序列，并满足： 每对相邻的单词之间仅有单个字母不同。 转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordList 中的单词。 注意，beginWord 不必是字典 wordList 中的单词。 sk == endWord 给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。 请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ， 如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回。  ``` 示例 1： 输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"] 输出：[["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]] 解释：存在 2 种最短的转换序列： "hit" -> "hot" -> "dot" -> "dog" -> "cog" "hit" -> "hot" -> "lot" -> "log" -> "cog" 示例 2： 输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"] 输出：[] 解释：endWord "cog" 不在字典 wordList 中，所以不存在符合要求的转换序列。 ``` 提示： 1 <= beginWord.length <= 7 endWord.length == beginWord.length 1 <= wordList.length <= 5000 wordList[i].length == beginWord.length beginWord、endWord 和 wordList[i] 由小写英文字母组成 beginWord != endWord wordList 中的所有单词 互不相同
●	乐队演出的最少花费
#大厂刷题班27
●	每一个项目都有三个数，[a,b,c]表示项目a和b乐队参演，花费为c 给定很多个项目int[][] programs 每一个乐队可能在多个项目里都出现了，但是只能挑一次 nums是可以挑选的项目数量，所以一定会有nums * 2只乐队被挑选出来 返回一共挑nums轮(也就意味着一定请到所有的乐队)，最少花费是多少？ nums < 9, programs长度小于500，每组测试乐队的全部数量一定是nums * 2，且标号一定是0 ~ nums * 2-1
●	企鹅的最少数量
#大厂刷题班27
●	企鹅厂每年都会发文化衫，文化衫有很多种颜色，厂庆的时候，企鹅们都需要穿文化衫来拍照 一次采访中，记者随机遇到的企鹅，企鹅会告诉记者还有多少企鹅跟他穿一个颜色的文化衫 我们将这些回答放在 answers 数组里，返回鹅厂中企鹅的最少数量。 输入: answers = [1] 一个人回答，还有 1 个人跟他穿一样颜色的文化衫，所以最少是 2个人， 输出 2 输入: answers = [1, 1, 2] 输出: 5
●	以下是LeetCode高频题(共计158题, 新讲述共81=78+1(639H)+1(119E)+1(拼多多)题
●	leetcode全题目列表 : https://leetcode-cn.com/problemset/all/
●	在全题目列表的右侧栏，点击Top Interview Questions
●	或者直接进入右侧链接 : https://leetcode-cn.com/problemset/all/?listId=wpwgkgt
●	即可看到leetcode高频题全列表
●	1.两数之和
#大厂刷题班27 #Easy  #LeetCode
●	2.两个链表相加
#新手班04 #Medium  #LeetCode
●	3.无重复字符的最长子串
 #Medium  #LeetCode
●	4. 寻找两个正序数组的中位数
#大厂刷题班12 #Hard  #LeetCode
●	5.最长回文子串
#Manacher算法 #体系班28 #Medium  #LeetCode
●	7.整数反转
#大厂刷题班27 #Easy  #LeetCode
●	8.字符串转换整数 (atoi)
#大厂刷题班28  #Easy  #LeetCode
●	10.正则表达式匹配
#大厂刷题班12 #Medium  #LeetCode
●	11.盛最多水的容器
#大厂刷题班8 #Medium  #LeetCode
●	12.整数转罗马数字
#大厂刷题班28 #Medium  #LeetCode
●	13.罗马数字转整数
#大厂刷题班28 #Easy  #LeetCode
●	14.最长公共前缀
#大厂刷题班28 #Easy  #LeetCode
●	15.三数之和
#大厂刷题班25 #Medium  #LeetCode
●	17.电话号码的字母组合
#大厂刷题班28 #Medium  #LeetCode #DFS #深度优先遍历
●	19.删除链表的倒数第N个节点
#大厂刷题班28 #Medium  #LeetCode
●	20.有效的括号
#大厂刷题班28 #Easy  #LeetCode
●	21.合并两个有序链表
#新手班04 #Easy  #LeetCode
●	第4节第6题
●	22.括号生成
#大厂刷题班28 #Medium  #LeetCode #剪枝 #DFS #深度优先遍历
●	23.合并多个有序链表
#新手班06 #Hard  #LeetCode
●	26.删除排序数组中的重复项
#大厂刷题班28 #Easy  #LeetCode
●	28.实现 strStr()
#KMP #体系班27 #Hard  #LeetCode
●	29.两数相除
#新手班05 #Medium  #LeetCode
●	34.在排序数组中查找元素的第一个和最后一个位置
#大厂刷题班28 #Medium  #LeetCode
●	36.有效的数独
#大厂刷题班28 #Medium  #LeetCode
●	37.解数独
#大厂刷题班28 #Hard  #LeetCode #DFS #深度优先遍历
●	38.外观数列
#大厂刷题班28 #Easy    #LeetCode
●	41.缺失的第一个正数
#大厂刷题班14 #Hard  #LeetCode
●	42. 接雨水
#大厂刷题班22 #Hard  #LeetCode
●	44.通配符匹配
#大厂刷题班12 #Hard  #LeetCode
●	45.跳跃游戏 II
#大厂刷题班10  #Hard  #LeetCode
●	46.全排列
#KMP #体系班27 #Medium  #LeetCode
●	48.旋转图像
#体系班40 #Medium  #LeetCode
●	49.字母异位词分组
#大厂刷题班28 #Medium  #LeetCode
●	33.搜索旋转排序数组
#大厂刷题班29 #Medium  #LeetCode
●	50.Pow(x, n)
#大厂刷题班29 #Medium  #LeetCode
●	53.最大子序和
#体系班40 #Easy  #LeetCode
●	54.螺旋矩阵
#体系班40 #Medium  #LeetCode
●	55.跳跃游戏
#体系班10 #Medium  #LeetCode
●	56.合并区间
#大厂刷题班29 #Medium  #LeetCode
●	62.不同路径
#大厂刷题班29 #Medium  #LeetCode
●	66.加一
#大厂刷题班29 #Easy  #LeetCode
●	69.x 的平方根
#大厂刷题班29 #Easy  #LeetCode #二分法
●	70.爬楼梯
#体系班26 #Easy  #LeetCode
●	73.矩阵置零
#大厂刷题班29 #Medium  #LeetCode
●	75.颜色分类
#体系班05 #Medium  #LeetCode
●	第5节第2题, 快排中的荷兰国旗问题
●	76.最小覆盖子串
#大厂刷题班24 #Hard  #LeetCode
●	78.子集
#体系班17 #Medium  #LeetCode
●	第17节题目3, 生成子序列问题和本题一样的 打印一个字符串的全部排列，要求不要出现重复的排列
●	79.单词搜索
#大厂刷题班30 #Medium  #LeetCode
●	84. 柱状图中最大的矩形
#体系班25 #Hard  #LeetCode
●	88.合并两个有序数组
#大厂刷题班30 #Easy  #LeetCode
●	91.解码方法
#体系班19 #Medium  #LeetCode #从左往右的尝试模型
●	639. 解码方法 II
#大厂刷题班30 #Hard  #LeetCode
●	一条包含字母 A-Z 的消息通过以下的方式进行了编码： 'A' -> 1 'B' -> 2 ... 'Z' -> 26 除了上述的条件以外，现在加密字符串可以包含字符 '* '了，字符'* '可以被当做1到9当中的任意一个数字。 给定一条包含数字和字符'* '的加密信息，请确定解码方法的总数。 同时，由于结果值可能会相当的大，所以你应当对109 + 7取模。（翻译者标注：此处取模主要是为了防止溢出） ``` 示例 1 : 输入: "*" 输出: 9 解释: 加密的信息可以被解密为: "A", "B", "C", "D", "E", "F", "G", "H", "I". 示例 2 : 输入: "1*" 输出: 9 + 9 = 18（翻译者标注：这里1*可以分解为1,* 或者当做1*来处理，所以结果是9+9=18） ``` 说明 : 输入的字符串长度范围是 [1, 105]。 输入的字符串只会包含字符 '*' 和 数字'0' - '9'。
●	94.二叉树的中序遍历
#体系班30  #Morris遍历
●	98.验证二叉搜索树
#大厂刷题班30  #Medium  #LeetCode
●	101.对称二叉树
#大厂刷题班30   #Easy   #LeetCode
●	102.二叉树的层序遍历
#新手标07  #Medium  #LeetCode
●	103.二叉树的锯齿形层次遍历
●	104.二叉树的最大深度
 #LeetCode   #Easy #二叉树的递归套路 #Morris遍历 #太简单跳过
●	105.从前序与中序遍历序列构造二叉树
#新手班06  #Medium  #LeetCode
●	108.将有序数组转换为二叉搜索树
 #大厂刷题班30  #LeetCode   #Easy
●	116.填充每个节点的下一个右侧节点指针
 #大厂刷题班30  #LeetCode  #Medium #BFS #宽度优先遍历
●	118.杨辉三角
 #大厂刷题班30  #LeetCode   #Easy
●	119. 杨辉三角 II
 #大厂刷题班30  #LeetCode   #Easy
●	121.买卖股票的最佳时机
 #大厂刷题班15   #LeetCode   #Easy
●	122.买卖股票的最佳时机 II
 #大厂刷题班15   #LeetCode   #Easy
●	123.买卖股票的最佳时机 III
 #大厂刷题班15   #LeetCode    #Hard
●	124.二叉树中的最大路径和
 #大厂刷题班30   #LeetCode    #Hard
●	125.验证回文串
 #大厂刷题班31  #LeetCode   #Easy #双指针
●	127.单词接龙
 #大厂刷题班31  #LeetCode    #Medium
●	128.最长连续序列
 #大厂刷题班12  #LeetCode    #Medium
●	130.被围绕的区域
 #大厂刷题班31  #LeetCode    #Medium
●	131.分割回文串
 #大厂刷题班11  #LeetCode    #Medium
●	134.加油站
 #大厂刷题班25  #体系班24   #LeetCode    #Medium
●	136.只出现一次的数字
#体系班2   #LeetCode     #Easy
●	138.深度复制带有rand指针的链表
#体系班09   #LeetCode    #Medium
●	139.单词拆分
 #大厂刷题班31  #LeetCode    #Medium #从左往右的尝试模型
●	ref:  107 · 单词拆分（一）
#LintCode
●	140.单词拆分 II
 #大厂刷题班31  #LeetCode     #Hard #DFS #深度优先遍历 #根据动态规划表生成路径
●	141.环形链表
#体系班10    #LeetCode    #Easy
●	146.LRU内存替换算法的实现
 #大厂刷题班19   #LeetCode    #Medium
●	148.排序链表
 #大厂刷题班31  #LeetCode    #Medium #归并排序
●	149.直线上最多的点数
 #大厂刷题班25   #LeetCode     #Hard
●	150.逆波兰表达式求值
 #大厂刷题班31  #LeetCode    #Medium #栈
●	152.乘积最大子数组
#大厂刷题班32  #Medium #LeetCode #从左往右的尝试模型
●	155.实现最小栈
#体系班03 #Easy #LeetCode
●	160.相交链表
 #体系班10  #LeetCode   #Easy
●	162.寻找峰值
 #体系班01  #LeetCode   #Medium
●	163.缺失的区间
 #大厂刷题班32  #LeetCode    #Easy
●	给定一个排序的整数数组 nums ，其中元素的范围在 闭区间 [lower, upper] 当中，返回不包含在数组中的缺失区间。 ``` 示例： 输入: nums = [0, 1, 3, 50, 75], lower = 0 和 upper = 99, 输出: ["2", "4->49", "51->74", "76->99"] ```
●	166.分数到小数
 #大厂刷题班32  #LeetCode   #Medium
●	169. 多数元素
 #大厂刷题班23  #LeetCode   #Easy
●	171.Excel表列序号
 #大厂刷题班32  #LeetCode  #Easy
●	172.阶乘后的零
 #大厂刷题班32  #LeetCode  #Easy
●	179.最大数
 #体系班13  #LeetCode   #Medium
●	188.买卖股票的最佳时机 IV
 #大厂刷题班15  #LeetCode   #Hard
●	189.旋转数组
 #大厂刷题班32  #LeetCode  #Easy
●	190.颠倒二进制位
 #大厂刷题班32  #LeetCode  #Easy
●	191.位1的个数
 #大厂刷题班32  #LeetCode  #Easy
●	198.打家劫舍
 #大厂刷题班04  #LeetCode   #Easy
●	200.岛屿数量
 #体系班15  #LeetCode   #Medium
●	202.快乐数
 #大厂刷题班32  #LeetCode  #Easy #硬记
●	204.计数质数
 #大厂刷题班32  #LeetCode  #Easy #素数筛法
●	素数筛法
●	埃氏筛法
●	操作：先把所有整数列出来，然后把2的倍数全部剔除，然后是三的，以此类推，遍历所有素数，把倍数全部划去。
●	对于每个数字i，如果没被划去，它一定是素数，因为它不是任何2到i-1数字的倍数。然后就开始划它的倍数就好。
 
●	合法的卷子数量
#大厂刷题班32 #拼多多 #从左往右的尝试模型
●	给定一个数组arr，arr[i] = j，表示第i号试题的难度为j。给定一个非负数M 想出一张卷子，对于任何相邻的两道题目，前一题的难度不能超过后一题的难度+M 返回所有可能的卷子种数 --- 题目描述：   多多打算将N道试题按一定顺序排列，组成一场考试，每道题有一定的难度Ai,一场合理考试的题目难度应该是从低到高的，多多希望难度升序，但又不完全升序，相部的题目中前一道题比后一道题难一点点也是可以的。   在对于一个题目序列，只要相邻的题目中前一道题的难度不超过后一道题的难度+M,就认为是满足的序列。求有多个序列是满足的序列。   输入描述：   第一行输入为两个整数N,M,含义如题目描述所示。   第二行为N个整数，分别表示每道题的难度。
●	206.反转链表
 #LeetCode   #Easy #太简单跳过
●	207.课程表
 #大厂刷题班33  #LeetCode   #Medium #拓扑排序
●	208.实现 Trie (前缀树)
 #体系班08  #LeetCode   #Medium
●	210.课程表 II
 #大厂刷题班33  #LeetCode   #Medium
●	212. 单词搜索 II
 #大厂刷题班26   #LeetCode   #Hard
●	213.打家劫舍 II
 #大厂刷题班33  #LeetCode   #Medium
●	215.数组中的第K个最大元素
 #体系班29  #LeetCode   #Medium
●	217.存在重复元素
 #LeetCode   #Easy #太简单跳过
●	218.天际线问题
 #大厂刷题班04  #LeetCode   #Hard
●	227.基本计算器 II
 #大厂刷题班08  #LeetCode   #Medium
●	230.二叉搜索树中第K小的元素
 #LeetCode   #Medium  #二叉树遍历 #Morris遍历  #太简单跳过
●	234.回文链表
 #体系班09  #LeetCode    #Easy
●	236.二叉树的最近公共祖先
 #体系班13  #大厂刷题班23   #LeetCode   #Medium #最近公共祖先
●	237.删除链表中的节点
 #大厂刷题班33  #LeetCode    #Easy
●	238.除自身以外数组的乘积
 #大厂刷题班33  #LeetCode   #Medium
●	239. 滑动窗口最大值
 #LeetCode    #Hard
●	240.搜索二维矩阵 II
 #LeetCode   #Medium
●	242.有效的字母异位词
 #大厂刷题班33  #LeetCode    #Easy
●	251.展开二维向量
 #大厂刷题班33  #LeetCode   #Medium
●	253.会议室 II
 #体系班07  #LeetCode   #Medium #最大线段重合问题
●	268.缺失数字
 #体系班14  #LeetCode    #Easy
●	269.火星词典
 #大厂刷题班33  #LeetCode    #Hard #拓扑排序
●	277.搜寻名人
 #大厂刷题班33  #LeetCode   #Medium
●	279.完全平方数
 #大厂刷题班33  #LeetCode   #Medium
●	283.移动零
 #大厂刷题班33  #LeetCode    #Easy
●	285.二叉搜索树中的顺序后继
#二叉树遍历 #Morris遍历  #LeetCode   #Medium  #太简单跳过
●	287.寻找重复数
 #大厂刷题班34  #LeetCode   #Medium
●	289.生命游戏
 #大厂刷题班34  #LeetCode   #Medium
●	295.数据流的中位数
 #大厂刷题班34  #LeetCode    #Hard #堆
●	297.二叉树的序列化与反序列化
 #体系班11  #LeetCode   #Hard
●	300.最长递增子序列
 #大厂刷题班09  #LeetCode    #Medium
●	308.二维区域和检索 - 可变
 #体系班32  #LeetCode   #Hard
●	309.最佳买卖股票时机含冷冻期
 #大厂刷题班15  #LeetCode    #Medium
●	315.计算右侧小于当前元素的个数
 #大厂刷题班34  #LeetCode   #Hard
●	322.零钱兑换
 #体系班21  #体系班22   #LeetCode    #Medium #硬币找零
●	324.摆动排序 II
 #大厂刷题班34  #LeetCode    #Medium
●	326.3的幂
 #大厂刷题班34  #LeetCode     #Easy
●	328.奇偶链表
 #大厂刷题班34  #LeetCode    #Medium
●	329.矩阵中的最长递增路径
 #大厂刷题班01  #LeetCode   #Hard
●	334.递增的三元子序列
 #大厂刷题班09   #LeetCode   #Medium  #太简单跳过
●	340.至多包含 K 个不同字符的最长子串
 #大厂刷题班34  #LeetCode     #Hard
●	341.扁平化嵌套列表迭代器
 #大厂刷题班34  #LeetCode    #Medium #栈
●	344.反转字符串
 #LeetCode   #Easy #太简单跳过
●	347.前 K 个高频元素
 #LeetCode   #Medium #门槛堆
●	348.判定井字棋胜负
 #大厂刷题班34  #LeetCode    #Medium
●	350.两个数组的交集 II
 #LeetCode   #Easy #太简单跳过
●	371.两整数之和
#新手班05  #LeetCode   #Easy
●	378.有序矩阵中第K小的元素
 #大厂刷题班17  #LeetCode    #Medium
●	380.常数时间插入、删除和获取随机元素
#大厂刷题班34  #LeetCode   #Medium #哈希表
●	384.打乱数组
#大厂刷题班34  #LeetCode   #Medium
●	387.字符串中的第一个唯一字符
 #LeetCode   #Easy #太简单跳过
●	395.至少有K个重复字符的最长子串
 #大厂刷题班35  #LeetCode   #Medium
●	412.Fizz Buzz
 #大厂刷题班35  #LeetCode   #Easy
●	454.四数相加 II
 #大厂刷题班35  #LeetCode   #Medium
●	673.最长递增子序列的个数
 #大厂刷题班35  #LeetCode   #Medium #难题
●	687.最长同值路径
 #大厂刷题班35  #LeetCode   #Easy #二叉树的递归套路
●	772.基本计算器 III
 #大厂刷题班08  #LeetCode    #Hard
●	以下是2021年8大厂真实笔试题(共计16题)
●	给定字符串str是总序列中的第几个
#大厂刷题班35
●	给定一个长度len,表示一共有几位   所有字符都是小写(a~z),可以生成长度为1,长度为2, 长度为3...长度为len的所有字符串   如果把所有字符串根据字典序排序，每个字符串都有所在的位置。   给定一个字符串str,给定len,请返回str是总序列中的第几个   比如len=4,字典序的前几个字符串为:   a aa aaa aaaa aaab..aaaz..azzz b ba baa baaa..bzzz c ...   a是这个序列中的第1个，bzzz是这个序列中的第36558个
●	 思路：  cdb，总共长度为7，请问cdb是第几个？  第一位c :  以a开头，剩下长度为(0~6)的所有可能性有几个  +  以b开头，剩下长度为(0~6)的所有可能性有几个  +  以c开头，剩下长度为(0)的所有可能性有几个  第二位d :  +  以ca开头的情况下，剩下长度为(0~5)的所有可能性有几个  +  以cb开头的情况下，剩下长度为(0~5)的所有可能性有几个  +  以cc开头的情况下，剩下长度为(0~5)的所有可能性有几个  +  以cd开头的情况下，剩下长度为(0)的所有可能性有几个  第三位b  +  以cda开头的情况下，剩下长度为(0~4)的所有可能性有几个  +  以cdb开头的情况下，剩下长度为(0)的所有可能性有几个
●	改变石头颜色的最优代价
#小红书 #大厂刷题班35
●	[0,4,7] ： 0表示这里石头没有颜色，如果变红代价是4，如果变蓝代价是7   [1,X,X] ： 1表示这里石头已经是红，而且不能改颜色，所以后两个数X无意义   [2,X,X] ： 2表示这里石头已经是蓝，而且不能改颜色，所以后两个数X无意义   颜色只可能是0、1、2，代价一定>=0   给你一批这样的小数组，要求最后必须所有石头都有颜色，且红色和蓝色一样多，返回最小代价   如果怎么都无法做到所有石头都有颜色、且红色和蓝色一样多，返回-1
●	最大观影时间
#小红书 #样本对应模型 #大厂刷题班35
●	一场电影开始和结束时间可以用一个小数组来表示["07:30","12:00"]   已知有2000场电影开始和结束都在同一天，这一天从00:00开始到23:59结束   一定要选3场完全不冲突的电影来观看，返回最大的观影时间   如果无法选出3场完全不冲突的电影来观看，返回-1
●	走到右下角的最小代价
#网易  A*寻路算法 #大厂刷题班35
●	map[i][j] == 0，代表(i,j)是海洋，渡过的话代价是2   map[i][j] == 1，代表(i,j)是陆地，渡过的话代价是1   map[i][j] == 2，代表(i,j)是障碍，无法渡过   每一步上、下、左、右都能走，返回从左上角走到右下角最小代价是多少，如果无法到达返回-1
●	环形小朋友分糖问题
#网易 #大厂刷题班35
●	给定一个正数数组arr，表示每个小朋友的得分   任何两个相邻的小朋友，如果得分一样，怎么分糖果无所谓，但如果得分不一样，分数大的一定要比分数少的多拿一些糖果   假设所有的小朋友坐成一个环形，返回在不破坏上一条规则的情况下，需要的最少糖果数
●	ref: 135.分糖果问题
●	返回第K位的字符
#大厂刷题班36  #网易
●	规定：L[1]对应a，L[2]对应b，L[3]对应c，...，L[25]对应y   S1 = a   S(i) = S(i-1) + L[i] + reverse(invert(S(i-1)));   解释invert操作：   S1 = a   S2 = aby   假设invert(S(2)) = 甲乙丙   a + 甲 = 26, 那么 甲 = 26 - 1 = 25 -> y   b + 乙 = 26, 那么 乙 = 26 - 2 = 24 -> x   y + 丙 = 26, 那么 丙 = 26 - 25 = 1 -> a   如上就是每一位的计算方式，所以invert(S2) = yxa   所以S3 = S2 + L[3] + reverse(invert(S2)) = aby + c + axy = abycaxy   invert(abycaxy) = yxawyba, 再reverse = abywaxy   所以S4 = abycaxy + d + abywaxy = abycaxydabywaxy   直到S25结束   给定两个参数n和k，返回Sn的第k位是什么字符，n从1开始，k从1开始   比如n=4，k=2，表示S4的第2个字符是什么，返回b字符
●	01字符串等比例划分的最多部分数
#大厂刷题班36  #网易
●	把一个01字符串切成多个部分，要求每一部分的0和1比例一样，同时要求尽可能多的划分   比如 : 01010101   01 01 01 01 这是一种切法，0和1比例为 1 : 1   0101 0101 也是一种切法，0和1比例为 1 : 1   两种切法都符合要求，但是那么尽可能多的划分为第一种切法，部分数为4 比如 : 00001111   只有一种切法就是00001111整体作为一块，那么尽可能多的划分，部分数为1 给定一个01字符串str，假设长度为N，要求返回一个长度为N的数组ans   其中ans[i] = str[0...i]这个前缀串，要求每一部分的0和1比例一样，同时要求尽可能多的划分下，部分数是多少   输入: str = "010100001"   输出: ans = [1, 1, 1, 2, 1, 2, 1, 1, 3]
●	相等的子串个数
#大厂刷题班36  #美团
●	给定两个字符串s1和s2 返回在s1中有多少个子串等于s2
●	计算括号字符串的分数
#大厂刷题班36  #美团
●	() 分值为2   (()) 分值为3   ((())) 分值为4   也就是说，每包裹一层，分数就是里面的分值+1   ()() 分值为2 * 2   (())() 分值为3 * 2   也就是说，每连接一段，分数就是各部分相乘，以下是一个结合起来的例子   (()())()(()) -> (2 * 2 + 1) * 2 * 3 -> 30   给定一个括号字符串str，已知str一定是正确的括号结合，不会有违规嵌套返回分数
●	设计高效查询的数据结构
#大厂刷题班36  #美团 #前缀和 #线段树
●	给定一个数组arr，长度为N，做出一个结构，可以高效的做如下的查询   1) int querySum(L,R) : 查询arr[L...R]上的累加和   2) int queryAim(L,R) : 查询arr[L...R]上的目标值，目标值定义如下：          假设arr[L...R]上的值为[a,b,c,d]，a+b+c+d = s          目标值为 : (s-a)^2 + (s-b)^2 + (s-c)^2 + (s-d)^2   3) int queryMax(L,R) : 查询arr[L...R]上的最大值   要求：   1) 初始化该结构的时间复杂度不能超过O(N*logN)   2) 三个查询的时间复杂度不能超过O(logN)   3) 查询时，认为arr的下标从1开始，比如 :       arr = [ 1, 1, 2, 3 ];      querySum(1, 3) -> 4      queryAim(2, 4) -> 50      queryMax(1, 4) -> 3
●	计算节点的权值
#大厂刷题班36  #美团
●	有一棵树，给定头节点h，和结构数组m，下标0弃而不用   比如h = 1, m = [ [] , [2,3], [4], [5,6], [], [], []]   表示1的孩子是2、3; 2的孩子是4; 3的孩子是5、6; 4、5和6是叶节点，都不再有孩子   每一个节点都有颜色，记录在c数组里，比如c[i] = 4, 表示节点i的颜色为4   一开始只有叶节点是有权值的，记录在w数组里，   比如，如果一开始就有w[i] = 3, 表示节点i是叶节点、且权值是3   现在规定非叶节点i的权值计算方式：   根据i的所有直接孩子来计算，假设i的所有直接孩子，颜色只有a,b,k   w[i] = Max {                (颜色为a的所有孩子个数 + 颜色为a的孩子权值之和),                 (颜色为b的所有孩子个数 + 颜色为b的孩子权值之和),                (颜色为k的所有孩子个数 + 颜色k的孩子权值之和)              }   请计算所有孩子的权值并返回
●	重新分类单链表
#大厂刷题班36  #腾讯
●	给定一个单链表的头节点head，每个节点都有value(>0)，给定一个正数m   value%m的值一样的节点算一类   请把所有的类根据单链表的方式重新连接好，返回每一类的头节点
●	拿走数字的最大分数
#大厂刷题班36   #腾讯
●	给定一个数组arr，当拿走某个数a的时候，其他所有的数都+a   请返回最终所有数都拿走的最大分数   比如: [2,3,1]   当拿走3时，获得3分，数组变成[5,4]   当拿走5时，获得5分，数组变成[9]   当拿走9时，获得9分，数组变成[]   这是最大的拿取方式，返回总分17
●	乘客坐船使用的最少船数 II
#大厂刷题班36
●	给定一个正数数组arr，代表每个人的体重。给定一个正数limit代表船的载重，所有船都是同样的载重量   每个人的体重都一定不大于船的载重   要求：   1, 可以1个人单独一搜船   2, 一艘船如果坐2人，两个人的体重相加需要是偶数，且总体重不能超过船的载重 3, 一艘船最多坐2人   返回如果想所有人同时坐船，船的最小数量
●	ref: 乘客坐船使用的最少船数
●	字典序最大的子序列
#大厂刷题班36  #腾讯  #单调栈
●	给定一个字符串str，和一个正数k   返回长度为k的所有子序列中，字典序最大的子序列
●	1510.石子游戏 IV
#大厂刷题班36 #哈啰单车  #LeetCode    #Hard
●	Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。 一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。 如果石子堆里没有石子了，则无法操作的玩家输掉游戏。 给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。  ``` 示例 1： 输入：n = 1 输出：true 解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。 示例 2： 输入：n = 2 输出：false 解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -> 1 -> 0）。 示例 3： 输入：n = 4 输出：true 解释：n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -> 0）。 示例 4： 输入：n = 7 输出：false 解释：当 Bob 采取最优策略时，Alice 无法赢得比赛。 如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -> 3 -> 2 -> 1 -> 0）。 如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -> 6 -> 2 -> 1 -> 0）。 示例 5： 输入：n = 17 输出：false 解释：如果 Bob 采取最优策略，Alice 无法赢得胜利。 ``` 提示： 1 <= n <= 10^5
●	815.公交路线
#大厂刷题班36  #LeetCode    #Hard   #三七互娱  #宽度优先遍历
●	给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。 例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... 这样的车站路线行驶。 现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。 求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。  ``` 示例 1： 输入：routes = [[1,2,7],[3,6,7]], source = 1, target = 6 输出：2 解释：最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。  示例 2： 输入：routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12 输出：-1 ``` 提示： 1 <= routes.length <= 500.   1 <= routes[i].length <= 10^5   routes[i] 中的所有值 互不相同   sum(routes[i].length) <= 10^5   0 <= routes[i][j] < 10^6   0 <= source, target < 10^6
●	以下是LeetCodeTop100Like题(共计100题, 新讲述共18题)
●	leetcode最受欢迎100题
●	leetcode全题目列表 : https://leetcode-cn.com/problemset/all/
●	在全题目列表的右侧栏，点击Top 100 Liked Questions
●	或者直接进入右侧链接 : https://leetcode-cn.com/problemset/all/?listId=79h8rn6
●	即可看到leetcode最受欢迎100题全列表
●	大厂刷题班27节~32节已经讲完leetcode高频题系列
●	leetcode高频题系列和leetcode最受欢迎100题系列题目有重合
●	以下为leetcode最受欢迎100题不和leetcode高频题重合的题号，其他的都重复了，不再讲述
●	32.最长有效括号
#大厂刷题班14  #LeetCode   #Hard
●	39.组合总和
 #LeetCode   #Medium  体系学习班, 硬币找零专题 : 第21节第2、3、4题, 第22节第2题, 第24节第4题。本题就是无限张找零问题，不再重复讲述
●	64.矩阵中的最小路径和
#体系班21  #LeetCode   #Medium
●	72.编辑距离问题: 经典中的经典
#大厂刷题班05  #LeetCode   #Medium
●	85.最大矩形
 #体系班25  #LeetCode   #Hard
●	ref: 86. 全是1的最大子矩形面积|最大矩形
●	96.不同的二叉搜索树
 #体系班39  #LeetCode   #Medium
●	114.二叉树展开为链表
 #大厂刷题班37  #LeetCode   #Medium  #二叉树的递归套路 #Morris遍历
●	142.环形链表 II
 #体系班10    #LeetCode   #Medium
●	221.最大正方形
 #大厂刷题班37  #LeetCode   #Medium #动态规划 #DP
●	226.翻转二叉树
 #大厂刷题班37  #LeetCode    #Easy
●	337.打家劫舍 III
 #大厂刷题班37  #LeetCode   #Medium
●	338.比特位计数
 #大厂刷题班30    #LeetCode   #Easy
●	ref: 191.位1的个数
●	394.字符串解码
 #大厂刷题班37  #LeetCode   #Medium
●	406.根据身高重建队列
 #大厂刷题班37  #LeetCode   #Medium
●	416.分割等和子集
 #大厂刷题班37  #LeetCode   #Medium #背包问题
●	437.路径总和 III
 #大厂刷题班37  #LeetCode   #Medium #前缀和
●	213.打家劫舍 II
 #大厂刷题班37 #奇安信  #LeetCode   #Medium
●	项目规划问题
 #大厂刷题班37 #网易 #拓扑排序
●	刚入职网易互娱，新人mini项目便如火如荼的开展起来。为了更好的项目协作与管理, 小易决定将学到的甘特图知识用于mini项目时间预估。小易先把项目中每一项工作以任务的形式列举出来, 每项任务有一个预计花费时间与前置任务表，必须完成了该任务的前置任务才能着手去做该任务。   作为经验PM,小易把任务划分得井井有条，保证没有前置任务或者前置任务全数完成的任务，都可以同时进行。   小易给出了这样一个任务表，请作为程序的你计算需要至少多长时间才能完成所有任务。   输入第一行为一个正整数T,表示数据组数。   对于接下来每组数据，第一行为一个正整数N,表示一共有N项任务。   接下来N行，每行先有两个整数Di和Ki,表示完成第i个任务的预计花费时间为Di天，该任务有Ki个前置任务。   之后为Ki个整数Mj,表示第Mj个任务是第i个任务的前置任务。   数据范围：对于所有数据，满足  1<=T<=3,1<=N,Mi<=100000,0<=Di<=1000,0<=sum(Ki)<=N*2。
●	扑克牌游戏的最大得分
 #大厂刷题班37 #字节
●	扑克牌中的红桃J和梅花Q找不到了，为了利用剩下的牌做游戏，小明设计了新的游戏规则   1) A,2,3,4....10,J,Q,K分别对应1到13这些数字，大小王对应0   2) 游戏人数为2人，轮流从牌堆里摸牌，每次摸到的牌只有“保留”和“使用”两个选项，且当前轮必须做出选择   3) 如果选择“保留”当前牌，那么当前牌的分数加到总分里，并且可以一直持续到游戏结束   4) 如果选择“使用”当前牌，那么当前牌的分数*3，加到总分上去，但是只有当前轮，下一轮，下下轮生效，之后轮效果消失。   5) 每一轮总分大的人获胜   假设小明知道每一轮对手做出选择之后的总分，返回小明在每一轮都赢的情况下，最终的最大分是多少   如果小明怎么都无法保证每一轮都赢，返回-1
●	438.找到字符串中所有字母异位词
 #大厂刷题班38  #LeetCode   #Medium #窗口
●	448.找到所有数组中消失的数字
 #大厂刷题班38  #LeetCode    #Easy
●	494.目标和
#大厂刷题班01  #LeetCode   #Medium
●	543.二叉树的直径
#体系班12  #LeetCode   #Easy
●	560.和为K的子数组
 #大厂刷题班38  #LeetCode   #Medium
●	581.最短无序连续子数组
 #大厂刷题班38  #LeetCode   #Medium
●	617.合并二叉树
 #大厂刷题班38  #LeetCode   #Medium
●	621.任务调度器
 #大厂刷题班38  #LeetCode   #Medium
●	647.回文子串
 #大厂刷题班38  #LeetCode   #Medium #Manacher
●	739.每日温度
 #大厂刷题班38  #LeetCode   #Medium #单调栈
●	763.划分字母区间
 #大厂刷题班38  #LeetCode   #Medium
●	两数游戏
 #大厂刷题班38 #字节
●	给定两个数a和b   第1轮，把1选择给a或者b   第2轮，把2选择给a或者b   ...   第i轮，把i选择给a或者b   想让a和b的值一样大，请问至少需要多少轮？
●	长城守卫军
 #大厂刷题班38 #360 #二分法 #线段树
●	题目描述：   长城上有连成一排的n个烽火台，每个烽火台都有士兵驻守。   第i个烽火台驻守着ai个士兵，相邻峰火台的距离为1。另外，有m位将军，   每位将军可以驻守一个峰火台，每个烽火台可以有多个将军驻守，   将军可以影响所有距离他驻守的峰火台小于等于x的烽火台。   每个烽火台的基础战斗力为士兵数，另外，每个能影响此烽火台的将军都能使这个烽火台的战斗力提升k。   长城的战斗力为所有烽火台的战斗力的最小值。   请问长城的最大战斗力可以是多少？   输入描述   第一行四个正整数n,m,x,k(1<=x<=n<=10^5,0<=m<=10^5,1<=k<=10^5)   第二行n个整数ai(0<=ai<=10^5)   输出描述 仅一行，一个整数，表示长城的最大战斗力   样例输入   5 2 1 2   4 4 2 4 4   样例输出   6
●	删除字符串的最大价值
#腾讯  #大厂刷题班39
●	给定一个只由0和1组成的字符串S，假设下标从1开始，规定i位置的字符价值V[i]计算方式如下 :  1) i == 1时，V[i] = 11) i == 1时，V[i] = 1 2) i > 1时，如果S[i] != S[i-1]，V[i] = 1 3) i > 1时，如果S[i] == S[i-1]，V[i] = V[i-1] + 1 你可以随意删除S中的字符，返回整个S的最大价值 字符串长度<=5000
●	满足条件的子数组个数
#腾讯  #大厂刷题班39 #从左往右的尝试模型
●	给定一个长度为n的数组arr，求有多少个子数组满足 :     子数组两端的值，是这个子数组的最小值和次小值，最小值和次小值谁在最左和最右无所谓     n<=100000
●	字符数必须是K种的子序列个数
 #大厂刷题班39 #百度 #单调栈
●	给定一个字符串str，和一个正数k     str子序列的字符种数必须是k种，返回有多少子序列满足这个条件      已知str中都是小写字母
●	二维矩阵的跳跃问题
 #大厂刷题班39  #京东 #线段树
●	给定一个二维数组matrix，matrix[i][j] = k代表:      从(i,j)位置可以随意往右跳<=k步，或者从(i,j)位置可以随意往下跳<=k步     如果matrix[i][j] = 0，代表来到(i,j)位置必须停止     返回从matrix左上角到右下角，至少要跳几次     已知matrix中行数n <= 5000, 列数m <= 5000
●	全消子序列
  #大厂刷题班39
●	一个子序列的消除规则如下:    1) 在某一个子序列中，如果'1'的左边有'0'，那么这两个字符->"01"可以消除    2) 在某一个子序列中，如果'3'的左边有'2'，那么这两个字符->"23"可以消除    3) 当这个子序列的某个部分消除之后，认为其他字符会自动贴在一起，可以继续寻找消除的机会   比如，某个子序列"0231"，先消除掉"23"，那么剩下的字符贴在一起变成"01"，继续消除就没有字符了    如果某个子序列通过最优良的方式，可以都消掉，那么这样的子序列叫做“全消子序列”   一个只由'0'、'1'、'2'、'3'四种字符组成的字符串str，可以生成很多子序列，返回“全消子序列”的最大长度    字符串str长度 <= 200
●	分裂数组中的1
#腾讯   #大厂刷题班40
●	一个数n，可以分裂成一个数组[n/2, n%2, n/2]   这个数组中哪个数不是1或者0，就继续分裂下去   比如 n = 5，一开始分裂成[2, 1, 2]   [2, 1, 2]这个数组中不是1或者0的数，会继续分裂下去，比如两个2就继续分裂   [2, 1, 2] -> [1, 0, 1, 1, 1, 0, 1]   那么我们说，5最后分裂成[1, 0, 1, 1, 1, 0, 1]   每一个数都可以这么分裂，在最终分裂的数组中，假设下标从1开始   给定三个数n、l、r，返回n的最终分裂数组里[l,r]范围上有几个1   n <= 2 ^ 50，n是long类型   r - l <= 50000，l和r是int类型   我们的课加个码:   n是long类型随意多大都行   l和r也是long类型随意多大都行，但要保证l<=r
●	被3整除的最大数
#去哪儿  #大厂刷题班40
●	给定一个arr，里面的数字都是0~9   你可以随意使用arr中的数字，哪怕打乱顺序也行   请拼出一个能被3整除的，最大的数字，用str形式返回
●	会议安排的最大收益
 #大厂刷题班40
●	给定int[][] meetings，比如   ``` {     {66, 70}   0号会议截止时间66，获得收益70     {25, 90}   1号会议截止时间25，获得收益90     {50, 30}   2号会议截止时间50，获得收益30   }   ``` 一开始的时间是0，任何会议都持续10的时间，但是一个会议一定要在该会议截止时间之前开始   只有一个会议室，任何会议不能共用会议室，一旦一个会议被正确安排，将获得这个会议的收益   请返回最大的收益
●	让数组有序
 #大厂刷题班40
●	给定两个数组A和B，长度都是N   A[i]不可以在A中和其他数交换，只可以选择和B[i]交换(0<=i<n)   你的目的是让A有序，返回你能不能做到
●	数组都变成一种数的最小次数
#腾讯  #大厂刷题班40
●	比如arr = {3,1,2,4}  下标对应是：0 1 2 3  下标对应是：0 1 2 3   你最开始选择一个下标进行操作，一旦最开始确定了是哪个下标，以后都只能在这个下标上进行操作   比如你选定1下标，1下标上面的数字是1，你可以选择变化这个数字，比如你让这个数字变成2   那么arr = {3,2,2,4}   下标对应是：0 1 2 3   因为你最开始确定了1这个下标，所以你以后都只能对这个下标进行操作，   但是，和你此时下标上的数字一样的、且位置连成一片的数字，会跟着一起变 比如你选择让此时下标1的数字2变成3，   那么arr = {3,3,3,4} 可以看到下标1和下标2的数字一起变成3，这是规则！一定会一起变   下标对应是：0 1 2 3   接下来，你还是只能对1下标进行操作，那么数字一样的、且位置连成一片的数字(arr[0~2]这个范围)都会一起变   决定变成4   那么arr = {4,4,4,4}   下标对应是：0 1 2 3   至此，所有数都成一样的了，你在下标1上做了3个决定(第一次变成2，第二次变成3，第三次变成4)，   因为联动规则，arr全刷成一种数字了   给定一个数组arr，最开始选择哪个下标，你随意   你的目的是一定要让arr都成为一种数字，注意联动效果会一直生效   返回最小的变化数    arr长度 <= 200, arr中的值 <= 10^6
●	无序数组变成有序数组的最小交换次数
#小红书   #大厂刷题班41
●	一个无序数组长度为n，所有数字都不一样，并且值都在[0...n-1]范围上   返回让这个无序数组变成有序数组的最小交换次数
●	最长的有效韵律子序列长度
#小红书   #大厂刷题班41
●	有四种诗的韵律分别为: AABB、ABAB、ABBA、AAAA   比如 : 1 1 3 3就属于AABB型的韵律、6 6 6 6就属于AAAA型的韵律等等   一个数组arr，当然可以生成很多的子序列，如果某个子序列一直以韵律的方式连接起来，我们称这样的子序列是有效的    比如, arr = { 1, 1, 15, 1, 34, 1, 2, 67, 3, 3, 2, 4, 15, 3, 17, 4, 3, 7, 52, 7, 81, 9, 9 } arr的一个子序列为{1, 1, 1, 1, 2, 3, 3, 2, 4, 3, 4, 3, 7, 7, 9, 9}   其中1, 1, 1, 1是AAAA、2, 3, 3, 2是ABBA、4, 3, 4, 3是ABAB、7, 7, 9, 9是AABB 可以看到，整个子序列一直以韵律的方式连接起来，所以这个子序列是有效的    给定一个数组arr, 返回最长的有效子序列长度   题目限制 : arr长度 <= 4000, arr中的值<= 10^9
●	到达N号节点的最小到达时间
#网易互娱  #大厂刷题班41
●	N个结点之间，表世界存在双向通行的道路，里世界存在双向通行的传送门. 若走表世界的道路，花费一分钟.   若走里世界的传送门，不花费时间，但是接下来一分钟不能走传送门. 输入： T为测试用例的组数，对于每组数据:   第一行：N M1 M2 N代表结点的个数1到N   接下来M1行 每行两个数，u和v，表示表世界u和v之间存在道路   接下来M2行 每行两个数，u和v，表示里世界u和v之间存在传送门   现在处于1号结点，最终要到达N号结点，求最小的到达时间 保证所有输入均有效，不存在环等情况
●	31.下一个排列
 #大厂刷题班41  #LeetCode   #Medium
●	实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。   如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须 原地 修改，只允许使用额外常数空间。   ``` 示例 1： 输入：nums = [1,2,3] 输出：[1,3,2] 示例 2： 输入：nums = [3,2,1] 输出：[1,2,3] 示例 3： 输入：nums = [1,1,5] 输出：[1,5,1] 示例 4： 输入：nums = [1] 输出：[1] ```
●	生命细胞问题数组版
#keep #大厂刷题班42
●	在一个数组中有 0 和1，数字 1 就是活细胞, 0 就认为是死细胞，整个数组不是 0 就1。   活细胞的规则就是活细胞会一直活。对于死细胞, 它临近位置有一个1它就会复活。之后它复活之后会一直存活,但如果死细胞临近位置有两个1，它就不能复活    ``` 例子:    [0 1 1 0 0 0 1 1 1 0]在经历过一个世代更替后会变为: [1 1 1 1 0 1 1 1 1 1], 这个数组再往下就不能迭代了,因为中间的0左右两侧都是1不能够复活 往后所有的世代都是它自己. [0 0 0 0 1 0 0 0 0 1 0 0 0]在经历过一个世代更替后会变为: [0 0 0 1 1 1 0 0 1 1 1 0 0]再经历过一个世代更替后会变为: [0 0 1 1 1 1 1 1 1 1 1 1 0] ``` 给你一个10^6规模的数组,  问迭代 M 代之后，这个数组变成什么样。M的数值可能非常大,约10^10.   请把数组原地调整好后返回.
●	数组还原
#国外 #大厂刷题班42
●	一个数组，比如说[1 2 4]，它按照规则会得到一个生成的数组. 生成数组的规则是:    首先原数组的数保留。其次每一个数乘 2 之后就是新数组的元素， 1 x 2=2, 2x2=4，4*2=8。得到新数组[1 2 4 2 4 8], 我们把这个数组叫做加工数组。 给你一个加工数组, 整个数组是打乱之后的，比如[4 2 2 8 1 4 4 2 8 1 4] ， 问能不能通过整个加工后的数组还原出原数组.    ``` 例子: 加工数组: [4 4 2 2 1 8]  原数组: [1 2 4] ```
●	收集二叉树的叶子节点
#国外 #大厂刷题班42  #拓扑排序
●	一颗有很多节点的二叉树需要收集所有节点, 具体的收集规则如下:    先收集那些为叶子的节点, 收集过的节点可以认为从原树中去掉了, 接着收集当前情况下为叶子的节点,  按照整个规则, 一直收集叶子节点, 直到最后收集头节点结束, 最后将收集好的节点序列返回.   当有多个叶子节点时, 节点间的先后顺序无所谓.
●	265.粉刷房子 II
 #大厂刷题班42  #LeetCode   #Hard
●	假如有一排房子，共 n 个，每个房子可以被粉刷成 k 种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。   当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x k 的矩阵来表示的。   例如，costs[0][0] 表示第 0 号房子粉刷成 0 号颜色的成本花费；costs[1][2] 表示第 1 号房子粉刷成 2 号颜色的成本花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。   注意：   所有花费均为正整数。   ``` 示例： 输入: [[1,5,3],[2,9,4]] 输出: 5 解释: 将 0 号房子粉刷成 0 号颜色，1 号房子粉刷成 2 号颜色。最少花费: 1 + 4 = 5;       或者将 0 号房子粉刷成 2 号颜色，1 号房子粉刷成 0 号颜色。最少花费: 3 + 2 = 5.  ``` 进阶： 您能否在 O(nk) 的时间复杂度下解决此问题？
●	272.最接近的二叉搜索树值 II
 #大厂刷题班42  #LeetCode   #Hard
●	给定一个不为空的二叉搜索树和一个目标值 target，请在该二叉搜索树中找到最接近目标值 target 的 k 个值。   注意：   给定的目标值 target 是一个浮点数   你可以默认 k 值永远是有效的，即 k ≤ 总结点数   题目保证该二叉搜索树中只会存在一种 k 个值集合最接近目标值   ``` 示例： 输入: root = [4,2,5,1,3]，目标值 = 3.714286，且 k = 2     4    / \   2   5  / \ 1   3 输出: [4,3] ``` 拓展： 假设该二叉搜索树是平衡的，请问您是否能在小于 O(n)（n 为总结点数）的时间复杂度内解决该问题呢？
●	273.整数转换英文表示
 #大厂刷题班42  #LeetCode   #Hard
●	将非负整数 num 转换为其对应的英文表示。  ``` 示例 1： 输入：num = 123 输出："One Hundred Twenty Three" 示例 2： 输入：num = 12345 输出："Twelve Thousand Three Hundred Forty Five" 示例 3：   输出："One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven" 示例 4： 输入：num = 1234567891输出："One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"输出："One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One" ``` 提示： 0 <= num <= 2^31 - 1  。
●	296.最佳的碰头地点
 #大厂刷题班42  #LeetCode   #Hard
●	有一队人（两人或以上）想要在一个地方碰面，他们希望能够最小化他们的总行走距离。   给你一个 2D 网格，其中各个格子内的值要么是 0，要么是 1。   1 表示某个人的家所处的位置。这里，我们将使用 曼哈顿距离 来计算，其中 distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|。   ``` 示例： 输入:  1 - 0 - 0 - 0 - 1 |   |   |   |   | 0 - 0 - 0 - 0 - 0 |   |   |   |   | 0 - 0 - 1 - 0 - 0 输出: 6  ``` 解析: 给定的三个人分别住在(0,0)，(0,4) 和 (2,2):      (0,2) 是一个最佳的碰面点，其总行走距离为 2 + 2 + 2 = 6，最小，因此返回 6。
●	335.路径交叉
 #大厂刷题班42  #LeetCode   #Hard
●	给定一个含有 n 个正数的数组 x。从点 (0,0) 开始，先向北移动 x[0] 米，然后向西移动 x[1] 米，向南移动 x[2] 米，向东移动 x[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。    编写一个 O(1) 空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。    ``` 示例 1: ┌───┐ │           │ └───┼──>               │ 输入: [2,1,1,2] 输出: true  示例 2: ┌──────┐ │                      │ │ │ └────────────> 输入: [1,2,3,4] 输出: false  示例 3: ┌───┐ │           │ └───┼> 输入: [1,1,1,1] 输出: true  ```
●	变换非负数组的最小代价
 #大厂刷题班42 #微软
●	给定一个正数数组arr长度为n、正数x、正数y     你的目标是让arr整体的累加和<=0     你可以对数组中的数num执行以下三种操作中的一种，且每个数最多能执行一次操作 :      1）不变     2）可以选择让num变成0，承担x的代价     3）可以选择让num变成-num，承担y的代价   返回你达到目标的最小代价   数据规模 : 面试时面试官没有说数据规模
●	yeah！数组
 #大厂刷题班42  #360
●	给定一个正数数组arr，长度为n，下标0~n-1   arr中的0、n-1位置不需要达标，它们分别是最左、最右的位置   中间位置i需要达标，达标的条件是 : arr[i-1] > arr[i] 或者 arr[i+1] > arr[i]哪个都可以   你每一步可以进行如下操作：对任何位置的数让其-1   你的目的是让arr[1~n-2]都达标，这时arr称之为yeah！数组   返回至少要多少步可以让arr变成yeah！数组   数据规模 : 数组长度 <= 10000，数组中的值<=500
●	248.中心对称数 III
 #大厂刷题班43  #LeetCode   #Hard
●	中心对称数是指一个数字在旋转了 180 度之后看起来依旧相同的数字（或者上下颠倒地看）。 写一个函数来计算范围在 [low, high] 之间中心对称数的个数。 ``` 示例: 输入: low = "50", high = "100" 输出: 3  解释: 69，88 和 96 是三个在该范围内的中心对称数 注意: 由于范围可能很大，所以 low 和 high 都用字符串表示。 ```
●	317.离建筑物最近的距离
 #大厂刷题班43  #LeetCode   #Hard
●	你是个房地产开发商，想要选择一片空地 建一栋大楼。你想把这栋大楼够造在一个距离周边设施都比较方便的地方，通过调研，你希望从它出发能在 最短的距离和 内抵达周边全部的建筑物。请你计算出这个最佳的选址到周边全部建筑物的 最短距离和。  你只能通过向上、下、左、右四个方向上移动。 0 代表你可以自由通过和选择建造的空地0 代表你可以自由通过和选择建造的空地0 代表你可以自由通过和选择建造的空地 1 代表你无法通行的建筑物 2 代表你无法通行的障碍物   ``` 示例： 输入：[[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]] 1 - 0 - 2 - 0 - 1  |    |     |     |     | 0 - 0 - 0 - 0 - 0  |    |     |     |     | 0 - 0 - 1 - 0 - 0 输出：7  解析： 给定三个建筑物 (0,0)、(0,4) 和 (2,2) 以及一个位于 (0,2) 的障碍物。由于总距离之和 3+3+1=7 最优，所以位置 (1,2) 是符合要求的最优地点，故返回7。由于总距离之和 3+3+1=7 最优，所以位置 (1,2) 是符合要求的最优地点，故返回7。 ``` 注意：题目数据保证至少存在一栋建筑物，如果无法按照上述规则返回建房地点，则请你返回 -1。题目数据保证至少存在一栋建筑物，如果无法按照上述规则返回建房地点，则请你返回 -1。
●	352.将数据流变为多个不相交区间
 #大厂刷题班43  #LeetCode   #Hard
●	给定一个非负整数的数据流输入 a1，a2，…，an，…，将到目前为止看到的数字总结为不相交的区间列表。 ``` 例如，假设数据流中的整数为 1，3，7，2，6，…，每次的总结为： [1, 1] [1, 1], [3, 3] [1, 1], [3, 3], [7, 7] [1, 3], [7, 7] [1, 3], [6, 7] ``` 进阶： 如果有很多合并，并且与数据流的大小相比，不相交区间的数量很小，该怎么办?
●	358.K 距离间隔重排字符串
 #大厂刷题班43  #LeetCode   #Hard
●	给你一个非空的字符串 s 和一个整数 k，你要将这个字符串中的字母进行重新排列，使得重排后的字符串中相同字母的位置间隔距离至少为 k。 所有输入的字符串都由小写字母组成，如果找不到距离至少为 k 的重排结果，请返回一个空字符串 ""。 ``` 示例 1： 输入: s = "aabbcc", k = 3 输出: "abcabc"  解释: 相同的字母在新的字符串中间隔至少 3 个单位距离。 示例 2: 输入: s = "aaabc", k = 3 输出: ""  解释: 没有办法找到可能的重排结果。 示例 3: 输入: s = "aaadbbcc", k = 2 输出: "abacabcd" 解释: 相同的字母在新的字符串中间隔至少 2 个单位距离。 ```
●	363.矩形区域不超过 K 的最大数值和
 #大厂刷题班43  #LeetCode   #Hard
●	给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。 题目数据保证总会存在一个数值和不超过 k 的矩形区域。 ``` 示例 1： 输入：matrix = [[1,0,1],[0,-2,3]], k = 2 输出：2 解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。 示例 2： 输入：matrix = [[2,2,-1]], k = 3 输出：3   提示： m == matrix.length n == matrix[i].length 1 <= m, n <= 100 -100 <= matrix[i][j] <= 100 -105 <= k <= 105 ``` 进阶：如果行数远大于列数，该如何设计解决方案？
●	391.完美矩形
 #大厂刷题班43  #LeetCode   #Hard
●	我们有 N 个与坐标轴对齐的矩形, 其中 N > 0, 判断它们是否能精确地覆盖一个矩形区域。 每个矩形用左下角的点和右上角的点的坐标来表示。例如， 一个单位正方形可以表示为 [1,1,2,2]。 ( 左下角的点的坐标为 (1, 1) 以及右上角的点的坐标为 (2, 2) )。 ``` 示例 1: rectangles = [   [1,1,3,3],   [3,1,4,2],   [3,2,4,4],   [1,3,2,4],   [2,3,3,4] ] 返回 true。5个矩形一起可以精确地覆盖一个矩形区域。  示例 2: rectangles = [   [1,1,2,3],   [1,3,2,4],   [3,1,4,2],   [3,2,4,4] ] 返回 false。两个矩形之间有间隔，无法覆盖成一个矩形。   示例 3: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [3,2,4,4] ] 返回 false。图形顶端留有间隔，无法覆盖成一个矩形。   示例 4: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [2,2,4,4] ] 返回 false。因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。 ```
●	992.K 个不同整数的子数组
 #大厂刷题班44  #LeetCode   #Hard
●	给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定不同的子数组为好子数组。 （例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。） 返回 A 中好子数组的数目。  ``` 示例 1： 输入：A = [1,2,1,2,3], K = 2 输出：7 解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. 示例 2： 输入：A = [1,2,1,3,4], K = 3 输出：3 解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].   提示： 1 <= A.length <= 20000 1 <= A[i] <= A.length 1 <= K <= A.length ```
●	248.中心对称数 III
#大厂刷题班44  #LeetCode   #Hard
●	中心对称数是指一个数字在旋转了 180 度之后看起来依旧相同的数字（或者上下颠倒地看）。 写一个函数来计算范围在 [low, high] 之间中心对称数的个数。 ``` 示例: 输入: low = "50", high = "100" 输出: 3  解释: 69，88 和 96 是三个在该范围内的中心对称数 注意: 由于范围可能很大，所以 low 和 high 都用字符串表示。 ```
●	317.离建筑物最近的距离
#大厂刷题班44  #LeetCode   #Hard
●	堆积木
 #大厂刷题班45
●	小明手中有n块积木，并且小明知道每块积木的重量。现在小明希望将这些积木堆起来 要求是任意一块积木如果想堆在另一块积木上面，那么要求： 1) 上面的积木重量不能小于下面的积木重量 2) 上面积木的重量减去下面积木的重量不能超过x 3) 每堆中最下面的积木没有重量要求 现在小明有一个机会，除了这n块积木，还可以获得k块任意重量的积木。 小明希望将积木堆在一起，同时希望积木堆的数量越少越好，你能帮他找到最好的方案么？   ``` 输入描述:    第一行三个整数n,k,x，1<=n<=200000，0<=x,k<=1000000000 第二行n个整数，表示积木的重量，任意整数范围都在[1,1000000000] 样例输出： n = 13 k = 1 x = 38 arr : 20 20 80 70 70 70 420 5 1 5 1 60 90 输出：2 解释： 两堆分别是 1 1 5 5 20 20 x 60 70 70 70 80 90 420 其中x是一个任意重量的积木，夹在20和60之间可以让积木继续往上搭 ```
●	291.单词规律 II
 #大厂刷题班45  #LeetCode   #Medium
●	给你一种规律 pattern 和一个字符串 str，请你判断 str 是否遵循其相同的规律。 这里我们指的是 完全遵循，例如 pattern 里的每个字母和字符串 str 中每个 非空 单词之间，存在着 双射 的对应规律。 双射 意味着映射双方一一对应，不会存在两个字符映射到同一个字符串，也不会存在一个字符分别映射到两个不同的字符串。  ``` 示例 1： 输入：pattern = "abab", s = "redblueredblue" 输出：true 解释：一种可能的映射如下： 'a' -> "red" 'b' -> "blue" 示例 2： 输入：pattern = "aaaa", s = "asdasdasdasd" 输出：true 解释：一种可能的映射如下： 'a' -> "asd" 示例 3： 输入：pattern = "abab", s = "asdasdasdasd" 输出：true 解释：一种可能的映射如下： 'a' -> "a" 'b' -> "sdasd" 注意 'a' 和 'b' 不能同时映射到 "asd"，因为这里的映射是一种双射。 示例 4： 输入：pattern = "aabb", s = "xyzabcxzyabc" 输出：false   提示： 0 <= pattern.length <= 20 0 <= s.length <= 50 pattern 和 s 由小写英文字母组成 ```
●	403.青蛙过河
 #大厂刷题班45  #LeetCode   #Hard
●	 一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。 给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。 开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。 如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。  ``` 示例 1： 输入：stones = [0,1,3,5,6,8,12,17] 输出：true 解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。 示例 2： 输入：stones = [0,1,2,3,4,8,9,11] 输出：false 解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。   提示： 2 <= stones.length <= 2000 0 <= stones[i] <= 231 - 1 stones[0] == 0 ```
●	2035.将数组分成两个数组并最小化数组和的差
 #大厂刷题班45 #LeetCode   #Hard
●	给你一个长度为 2 * n 的整数数组。你需要将 nums 分成 两个 长度为 n 的数组，分别求出两个数组的和，并 最小化 两个数组和之 差的绝对值 。nums 中每个元素都需要放入两个数组之一。 请你返回 最小 的数组和之差。  ``` 示例 1： 输入：nums = [3,9,7,3] 输出：2 解释：最优分组方案是分成 [3,9] 和 [7,3] 。 数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。 ```
 
●	``` 示例 2： 输入：nums = [-36,36] 输出：72 解释：最优分组方案是分成 [-36] 和 [36] 。 数组和之差的绝对值为 abs((-36) - (36)) = 72 。 示例 3： 输入：nums = [2,-1,0,4,-2,-9] 输出：0 解释：最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。 数组和之差的绝对值为 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0 。 ```
 
●	``` d 提示： 1 <= n <= 15 nums.length == 2 * n -107 <= nums[i] <= 107 ```
●	363.矩形区域不超过 K 的最大数值和
 #大厂刷题班46  #LeetCode   #Hard
●	给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。 题目数据保证总会存在一个数值和不超过 k 的矩形区域。 ![[Pasted image 20210930194529.png]]  ``` 示例 1： 输入：matrix = [[1,0,1],[0,-2,3]], k = 2 输出：2 解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。 示例 2： 输入：matrix = [[2,2,-1]], k = 3 输出：3   提示： m == matrix.length n == matrix[i].length 1 <= m, n <= 100 -100 <= matrix[i][j] <= 100 -105 <= k <= 105 ``` 进阶：如果行数远大于列数，该如何设计解决方案？
●	391.完美矩形
 #大厂刷题班46  #LeetCode   #Hard
●	我们有 N 个与坐标轴对齐的矩形, 其中 N > 0, 判断它们是否能精确地覆盖一个矩形区域。 每个矩形用左下角的点和右上角的点的坐标来表示。例如， 一个单位正方形可以表示为 [1,1,2,2]。  ( 左下角的点的坐标为 (1, 1) 以及右上角的点的坐标为 (2, 2) )。 ``` 示例 1: rectangles = [   [1,1,3,3],   [3,1,4,2],   [3,2,4,4],   [1,3,2,4],   [2,3,3,4] ] 返回 true。5个矩形一起可以精确地覆盖一个矩形区域。  示例 2: rectangles = [   [1,1,2,3],   [1,3,2,4],   [3,1,4,2],   [3,2,4,4] ] 返回 false。两个矩形之间有间隔，无法覆盖成一个矩形。   示例 3: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [3,2,4,4] ] 返回 false。图形顶端留有间隔，无法覆盖成一个矩形。   示例 4: rectangles = [   [1,1,3,3],   [3,1,4,2],   [1,3,2,4],   [2,2,4,4] ] 返回 false。因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。 ```
●	411.最短独占单词缩写
 #大厂刷题班46  #LeetCode   #Hard
●	通过将任意数量的 不相邻 子字符串替换为它们的长度，可以完成对字符串的 缩写 。  例如，像 "substitution" 这样的字符串可以缩写为（但不限于）：   "s10n" ("s ubstitutio n")   "sub4u4" ("sub stit u tion")   "12" ("substitution")   "su3i1u2on" ("su bst i t u ti on")   "substitution" (不替换子字符串)   注意："s55n" ("s ubsti tutio n") 不是 "substitution" 的有效缩写形式，因为它试图替换两个相邻的子字符串。   缩写的 长度 是未被替换的字母数加上被替换的字符串数。例如，缩写 "s10n" 的长度为 3（2 个字母 + 1 个子字符串），而 "su3i1u2on" 的长度为 9（6 个字母 + 3 子字符串）。   给你一个目标字符串 target 和一个字符串数组 dictionary 作为字典，为 target 找出并返回一个 最短 长度的缩写字符串，同时这个缩写字符串 不是 字典 dictionary 中其他字符串的缩写形式。如果有多个有效答案，可以返回其中任意一个。  ``` 示例 1： 输入：target = "apple", dictionary = ["blade"] 输出："a4" 解释："apple" 的最短缩写形式为 "5" ，但这也是 "blade" 的缩写形式之一。 下一组最短缩写是 "a4" 和 "4e" ，其中 "4e" 也是 "blade" 的缩写形式之一，而 "a4" 不是。 因此，返回 "a4" 。 示例 2： 输入：target = "apple", dictionary = ["blade","plain","amber"] 输出："1p3" 解释："5" 同时是 "apple" 和字典中所有单词的缩写形式。 "a4" 同时是 "apple" 和 "amber" 的缩写形式。 "4e" 同时是 "apple" 和 "blade" 的缩写形式。 "1p3"、"2p2" 和 "3l1" 是 "apple" 的下一组最短缩写形式。 因为它们不是字典中其他单词的缩写形式，返回其中任意一个都是正确的。 提示： target.length == m dictionary.length == n 1 <= m <= 21 0 <= n <= 1000 1 <= dictionary[i] <= 100 如果 n > 0 ，那么 log2(n) + m <= 21 ```
●	425.单词方块
 #大厂刷题班46  #LeetCode   #Hard
●	给定一个单词集合 （没有重复），找出其中所有的 单词方块 。   一个单词序列形成了一个有效的单词方块的意思是指从第 k 行和第 k 列 (0 ≤ k < max(行数, 列数)) 来看都是相同的字符串。   ``` 例如，单词序列 ["ball","area","lead","lady"] 形成了一个单词方块，因为每个单词从水平方向看和从竖直方向看都是相同的。 b a l l a r e a l e a d l a d y 注意： 单词个数大于等于 1 且不超过 500。 所有的单词长度都相同。 单词长度大于等于 1 且不超过 5。 每个单词只包含小写英文字母 a-z。  示例 1： 输入： ["area","lead","wall","lady","ball"] 输出： [   [ "wall",     "area",     "lead",     "lady"   ],   [ "ball",     "area",     "lead",     "lady"   ] ] 解释： 输出包含两个单词方块，输出的顺序不重要，只需要保证每个单词方块内的单词顺序正确即可。    示例 2： 输入： ["abat","baba","atan","atal"] 输出： [   [ "baba",     "abat",     "baba",     "atan"   ],   [ "baba",     "abat",     "baba",     "atal"   ] ] 解释： 输出包含两个单词方块，输出的顺序不重要，只需要保证每个单词方块内的单词顺序正确即可。  ```
●	动态开点线段树
 #大厂刷题班47
●	315.计算右侧小于当前元素的个数
 #大厂刷题班47  #LeetCode   #Hard #归并排序
●	从大往小merge, 相等的时候一定要先拷贝右边的数
●	ref:求数组小和
●	358.K 距离间隔重排字符串
 #大厂刷题班47  #LeetCode   #Hard
●	给你一个非空的字符串 s 和一个整数 k，你要将这个字符串中的字母进行重新排列，使得重排后的字符串中相同字母的位置间隔距离至少为 k。 所有输入的字符串都由小写字母组成，如果找不到距离至少为 k 的重排结果，请返回一个空字符串 ""。 ``` 示例 1： 输入: s = "aabbcc", k = 3 输出: "abcabc"  解释: 相同的字母在新的字符串中间隔至少 3 个单位距离。 示例 2: 输入: s = "aaabc", k = 3 输出: ""  解释: 没有办法找到可能的重排结果。 示例 3: 输入: s = "aaadbbcc", k = 2 输出: "abacabcd" 解释: 相同的字母在新的字符串中间隔至少 2 个单位距离。 ```
●	ref: 621.任务调度器
●	475.供暖器
 #大厂刷题班47  #LeetCode    #Medium
●	冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。 在加热器的加热半径范围内的每个房屋都可以获得供暖。 现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。 说明：所有供暖器都遵循你的半径标准，加热的半径也一样。  ``` 示例 1: 输入: houses = [1,2,3], heaters = [2] 输出: 1 解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。 示例 2: 输入: houses = [1,2,3,4], heaters = [1,4] 输出: 1 解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。 示例 3： 输入：houses = [1,5], heaters = [2] 输出：3   提示： 1 <= houses.length, heaters.length <= 3 * 10^4 1 <= houses[i], heaters[i] <= 10^9 ```
●	428.序列化和反序列化 N 叉树
 #大厂刷题班47  #LeetCode   #Hard
●	序列化是指将一个数据结构转化为位序列的过程，因此可以将其存储在文件中或内存缓冲区中，以便稍后在相同或不同的计算机环境中恢复结构。  设计一个序列化和反序列化 N 叉树的算法。一个 N 叉树是指每个节点都有不超过 N 个孩子节点的有根树。序列化 / 反序列化算法的算法实现没有限制。你只需要保证 N 叉树可以被序列化为一个字符串并且该字符串可以被反序列化成原树结构即可。   例如，你需要序列化下面的 3-叉 树。
 
●	 ``` 为 [1 [3[5 6] 2 4]]。你不需要以这种形式完成，你可以自己创造和实现不同的方法。 或者，您可以遵循 LeetCode 的层序遍历序列化格式，其中每组孩子节点由空值分隔。 ```
 
●	 ``` 例如，上面的树可以序列化为 [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] 你不一定要遵循以上建议的格式，有很多不同的格式，所以请发挥创造力，想出不同的方法来完成本题。 提示： 树中节点数目的范围是 [0, 104]. 0 <= Node.val <= 104 N 叉树的高度小于等于 1000 不要使用类成员 / 全局变量 / 静态变量来存储状态。你的序列化和反序列化算法应是无状态的。 ```
●	465.最优账单平衡
 #大厂刷题班47  #LeetCode   #Hard
●	一群朋友在度假期间会相互借钱。比如说，小爱同学支付了小新同学的午餐共计 10 美元。如果小明同学支付了小爱同学的出租车钱共计 5 美元。我们可以用一个三元组 (x, y, z) 表示一次交易，表示 x 借给 y 共计 z 美元。用 0, 1, 2 表示小爱同学、小新同学和小明同学（0, 1, 2 为人的标号），上述交易可以表示为 [[0, 1, 10], [2, 0, 5]]。 给定一群人之间的交易信息列表，计算能够还清所有债务的最小次数。 注意： 一次交易会以三元组 (x, y, z) 表示，并有 x ≠ y 且 z > 0。 人的标号可能不是按顺序的，例如标号可能为 0, 1, 2 也可能为 0, 2, 6。  ``` 示例 1： 输入： [[0,1,10], [2,0,5]] 输出： 2 解释： 人 #0 给人 #1 共计 10 美元。 人 #2 给人 #0 共计 5 美元。 需要两次交易。一种方式是人 #1 分别给人 #0 和人 #2 各 5 美元。   示例 2： 输入： [[0,1,10], [1,0,1], [1,2,5], [2,0,5]] 输出： 1 解释： 人 #0 给人 #1 共计 10 美元。Person #0 gave person #1 $10. 人 #1 给人 #0 共计 1 美元。Person #1 gave person #0 $1. 人 #1 给人 #2 共计 5 美元。Person #1 gave person #2 $5. 人 #2 给人 #0 共计 5 美元。Person #2 gave person #0 $5. 因此，人 #1 需要给人 #0 共计 4 美元，所有的债务即可还清。 ```
●	第K小的数字对差值
 #大厂刷题班48
●	比如{ 5, 3, 1, 4 }   全部数字对是：(5,3)、(5,1)、(5,4)、(3,1)、(3,4)、(1,4)   数字对的差值绝对值： 2、4、1、2、1、3   差值绝对值排序后：1、1、2、2、3、4   给定一个数组arr，和一个正数k   返回arr中所有数字对差值的绝对值，第k小的是多少 arr = { 5, 3, 1, 4 }, k = 4   返回2
●	472.连接词
 #大厂刷题班48  #LeetCode   #Hard  #瓜子 #前缀树 #Trie
●	给定一个 不含重复 单词的字符串数组 words ，编写一个程序，返回 words 中的所有 连接词 。 连接词 的定义为：一个字符串完全是由至少两个给定数组中的单词组成的。  ``` 示例 1： 输入：words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"] 输出：["catsdogcats","dogcatsdog","ratcatdogcat"] 解释："catsdogcats"由"cats", "dog" 和 "cats"组成;       "dogcatsdog"由"dog", "cats"和"dog"组成;       "ratcatdogcat"由"rat", "cat", "dog"和"cat"组成。 示例 2： 输入：words = ["cat","dog","catdog"] 输出：["catdog"]   提示： 1 <= words.length <= 104 0 <= words[i].length <= 1000 words[i] 仅由小写字母组成 0 <= sum(words[i].length) <= 105 ```
●	483.最小好进制
 #大厂刷题班48  #LeetCode   #Hard  #二分法
●	对于给定的整数 n, 如果n的k（k>=2）进制数的所有数位全为1，则称 k（k>=2）是 n 的一个好进制。 以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。  ``` 示例 1： 输入："13" 输出："3" 解释：13 的 3 进制是 111。 示例 2： 输入："4681" 输出："8" 解释：4681 的 8 进制是 11111。 示例 3： 输入："1000000000000000000" 输出："999999999999999999" 解释：1000000000000000000 的 999999999999999999 进制是 11。   提示： n的取值范围是 [3, 10^18]。 输入总是有效且没有前导 0。 ```
●	499.迷宫 III
 #大厂刷题班48  #LeetCode   #Hard
●	由空地和墙组成的迷宫中有一个球。球可以向上（u）下（d）左（l）右（r）四个方向滚动，但在遇到墙壁前不会停止滚动。当球停下时，可以选择下一个方向。迷宫中还有一个洞，当球运动经过洞时，就会掉进洞里。 给定球的起始位置，目的地和迷宫，找出让球以最短距离掉进洞里的路径。 距离的定义是球从起始位置（不包括）到目的地（包括）经过的空地个数。通过'u', 'd', 'l' 和 'r'输出球的移动方向。 由于可能有多条最短路径， 请输出字典序最小的路径。如果球无法进入洞，输出"impossible"。 迷宫由一个0和1的二维数组表示。 1表示墙壁，0表示空地。你可以假定迷宫的边缘都是墙壁。起始位置和目的地的坐标通过行号和列号给出。  ``` 示例1: 输入 1: 迷宫由以下二维数组表示 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 输入 2: 球的初始位置 (rowBall, colBall) = (4, 3) 输入 3: 洞的位置 (rowHole, colHole) = (0, 1) 输出: "lul" 解析: 有两条让球进洞的最短路径。 第一条路径是 左 -> 上 -> 左, 记为 "lul". 第二条路径是 上 -> 左, 记为 'ul'. 两条路径都具有最短距离6, 但'l' < 'u'，故第一条路径字典序更小。因此输出"lul"。 ``` ![[Pasted image 20211106211715.png|400]]    ``` 示例 2: 输入 1: 迷宫由以下二维数组表示 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 输入 2: 球的初始位置 (rowBall, colBall) = (4, 3) 输入 3: 洞的位置 (rowHole, colHole) = (3, 0) 输出: "impossible" 示例: 球无法到达洞。 ``` ![[Pasted image 20211106211700.png|400]]   ``` 注意: 迷宫中只有一个球和一个目的地。 球和洞都在空地上，且初始时它们不在同一位置。 给定的迷宫不包括边界 (如图中的红色矩形), 但你可以假设迷宫的边缘都是墙壁。 迷宫至少包括2块空地，行数和列数均不超过30。 ```
●	377.组合总和 Ⅳ
   #大厂刷题班49  #LeetCode   #Medium
●	给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。 题目数据保证答案符合 32 位整数范围。  ``` 示例 1： 输入：nums = [1,2,3], target = 4 输出：7 解释： 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 示例 2： 输入：nums = [9], target = 3 输出：0   提示： 1 <= nums.length <= 200 1 <= nums[i] <= 1000 nums 中的所有元素 互不相同 1 <= target <= 1000 ```
●	446.等差数列划分 II - 子序列
   #大厂刷题班49  #LeetCode    #Hard
●	给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。 如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。 例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。 再例如，[1, 1, 2, 5, 7] 不是等差序列。 数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。 例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。 题目数据保证答案是一个 32-bit 整数。  ``` 示例 1： 输入：nums = [2,4,6,8,10] 输出：7 解释：所有的等差子序列为： [2,4,6] [4,6,8] [6,8,10] [2,4,6,8] [4,6,8,10] [2,4,6,8,10] [2,6,10] 示例 2： 输入：nums = [7,7,7,7,7] 输出：16 解释：数组中的任意子序列都是等差子序列。   提示： 1  <= nums.length <= 1000 -2^31 <= nums[i] <= 2^31 - 1 ```
●	489.扫地机器人
   #大厂刷题班49  #LeetCode    #Hard
●	房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。 扫地机器人提供4个API，可以向前进，向左转或者向右转。每次转弯90度。 当扫地机器人试图进入障碍物格子时，它的碰撞传感器会探测出障碍物，使它停留在原地。 请利用提供的4个API编写让机器人清理整个房间的算法。 ``` interface Robot {   // 若下一个方格为空，则返回true，并移动至该方格   // 若下一个方格为障碍物，则返回false，并停留在原地   boolean move();   // 在调用turnLeft/turnRight后机器人会停留在原位置   // 每次转弯90度   void turnLeft();   void turnRight();   // 清理所在方格   void clean(); } 示例: 输入: room = [   [1,1,1,1,1,0,1,1],   [1,1,1,1,1,0,1,1],   [1,0,1,1,1,1,1,1],   [0,0,0,1,0,0,0,0],   [1,1,1,1,1,1,1,1] ], row = 1, col = 3 解析: 房间格栅用0或1填充。0表示障碍物，1表示可以通过。 机器人从row=1，col=3的初始位置出发。在左上角的一行以下，三列以右。 注意: 输入只用于初始化房间和机器人的位置。你需要“盲解”这个问题。换而言之，你必须在对房间和机器人位置一无所知的情况下，只使用4个给出的API解决问题。  扫地机器人的初始位置一定是空地。 扫地机器人的初始方向向上。 所有可抵达的格子都是相连的，亦即所有标记为1的格子机器人都可以抵达。 可以假定格栅的四周都被墙包围。 ```
●	527.单词缩写
   #大厂刷题班49  #LeetCode    #Hard
●	给你一个字符串数组 words ，该数组由 互不相同 的若干字符串组成，请你找出并返回每个单词的 最小缩写 。 生成缩写的规则如下： 初始缩写由起始字母+省略字母的数量+结尾字母组成。 若存在冲突，亦即多于一个单词有同样的缩写，则使用更长的前缀代替首字母，直到从单词到缩写的映射唯一。换而言之，最终的缩写必须只能映射到一个单词。 若缩写并不比原单词更短，则保留原样。  ``` 示例 1： 输入: words = ["like", "god", "internal", "me", "internet", "interval", "intension", "face", "intrusion"] 输出: ["l2e","god","internal","me","i6t","interval","inte4n","f2e","intr4n"] 示例 2： 输入：words = ["aa","aaa"] 输出：["aa","aaa"]   提示： 1 <= words.length <= 400 2 <= words[i].length <= 400 words[i] 由小写英文字母组成 words 中的所有字符串 互不相同 ```
●	548.将数组分割成和相等的子数组
   #大厂刷题班49  #LeetCode    #Hard
●	给定一个有 n 个整数的数组，你需要找到满足以下条件的三元组 (i, j, k) ： 0 < i, i + 1 < j, j + 1 < k < n - 1 子数组 (0, i - 1)，(i + 1, j - 1)，(j + 1, k - 1)，(k + 1, n - 1) 的和应该相等。 这里我们定义子数组 (L, R) 表示原数组从索引为L的元素开始至索引为R的元素。 ``` 示例: 输入: [1,2,1,2,1,2,1] 输出: True 解释: i = 1, j = 3, k = 5.  sum(0, i - 1) = sum(0, 0) = 1 sum(i + 1, j - 1) = sum(2, 2) = 1 sum(j + 1, k - 1) = sum(4, 4) = 1 sum(k + 1, n - 1) = sum(6, 6) = 1  注意: 1 <= n <= 2000。 给定数组中的元素会在 [-1,000,000, 1,000,000] 范围内。 ```
●	564.寻找最近的回文数
   #大厂刷题班49  #LeetCode    #Hard
●	 给定一个整数 n ，你需要找到与它最近的回文数（不包括自身）。 “最近的”定义为两个整数差的绝对值最小。 ``` 示例 1: 输入: "123" 输出: "121" 注意: n 是由字符串表示的正整数，其长度不超过18。 如果有多个结果，返回最小的那个。 ```
●	440.字典序的第K小数字
   #大厂刷题班49  #LeetCode    #Hard
●	给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。 注意：1 ≤ k ≤ n ≤ 109。 ``` 示例 : 输入: n: 13   k: 2 输出: 10 解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。 ```
●	568.最大休假天数
 #大厂刷题班50  #LeetCode   #Hard
●	力扣想让一个最优秀的员工在 N 个城市间旅行来收集算法问题。 但只工作不玩耍，聪明的孩子也会变傻，所以您可以在某些特定的城市和星期休假。您的工作就是安排旅行使得最大化你可以休假的天数，但是您需要遵守一些规则和限制。 ``` 规则和限制： 您只能在 N 个城市之间旅行，用 0 到 N-1 的索引表示。一开始，您在索引为0的城市，并且那天是星期一。 这些城市通过航班相连。这些航班用 N*N 矩阵 flights（不一定是对称的）表示，flights[i][j] 代表城市i到城市j的航空状态。如果没有城市i到城市j的航班，flights[i][j] = 0；否则，flights[i][j] = 1。同时，对于所有的i，flights[i][i] = 0。 您总共有 K 周（每周7天）的时间旅行。您每天最多只能乘坐一次航班，并且只能在每周的星期一上午乘坐航班。由于飞行时间很短，我们不考虑飞行时间的影响。 对于每个城市，不同的星期您休假天数是不同的，给定一个 N*K 矩阵 days 代表这种限制，days[i][j] 代表您在第j个星期在城市i能休假的最长天数。 给定 flights 矩阵和 days 矩阵，您需要输出 K 周内可以休假的最长天数。 示例 1: 输入:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]] 输出: 12 解释:  Ans = 6 + 3 + 3 = 12.  最好的策略之一： 第一个星期 : 星期一从城市0飞到城市1，玩6天，工作1天。  （虽然你是从城市0开始，但因为是星期一，我们也可以飞到其他城市。）  第二个星期 : 星期一从城市1飞到城市2，玩3天，工作4天。 第三个星期 : 呆在城市2，玩3天，工作4天。  示例 2: 输入:flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]] 输出: 3 解释:  Ans = 1 + 1 + 1 = 3.  由于没有航班可以让您飞到其他城市，你必须在城市0呆整整3个星期。  对于每一个星期，你只有一天时间玩，剩下六天都要工作。  所以最大休假天数为3.   示例 3: 输入:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]] 输出: 21 解释: Ans = 7 + 7 + 7 = 21 最好的策略之一是： 第一个星期 : 呆在城市0，玩7天。  第二个星期 : 星期一从城市0飞到城市1，玩7天。 第三个星期 : 星期一从城市1飞到城市2，玩7天。   注意: N 和 K 都是正整数，在 [1, 100] 范围内。 矩阵 flights 的所有值都是 [0, 1] 范围内的整数。 矩阵 days 的所有值都是 [0, 7] 范围内的整数。 超过休假天数您仍可以呆在那个城市，但是在额外的日子您需要 工作 ，这些日子不会算做休假日。 如果您从城市A飞往城市B并在当天休假日，这个休假会被算作是城市B的休假日。 我们不考虑飞行时间对计算休假日的影响。 ```
●	587.安装栅栏
 #大厂刷题班50  #LeetCode   #Hard  #凸包
●	在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。  ``` 示例 1: 输入: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] 输出: [[1,1],[2,0],[4,2],[3,3],[2,4]] 解释: ```
 
●	``` 示例 2: 输入: [[1,2],[2,2],[4,2]] 输出: [[1,2],[2,2],[4,2]] 解释: 即使树都在一条直线上，你也需要先用绳子包围它们。 ```
 
●	``` 注意: 所有的树应当被围在一起。你不能剪断绳子来包围树或者把树分成一组以上。 输入的整数在 0 到 100 之间。 花园至少有一棵树。 所有树的坐标都是不同的。 输入的点没有顺序。输出顺序也没有要求。 ```
●	588.设计内存文件系统
 #大厂刷题班50  #LeetCode   #Hard
●	设计一个内存文件系统，模拟以下功能： ls： 以字符串的格式输入一个路径。如果它是一个文件的路径，那么函数返回一个列表，仅包含这个文件的名字。如果它是一个文件夹的的路径，那么返回该 文件夹内 的所有文件和子文件夹的名字。你的返回结果（包括文件和子文件夹）应该按字典序排列。 mkdir：输入一个当前不存在的 文件夹路径 ，你需要根据路径名创建一个新的文件夹。如果有上层文件夹路径不存在，那么你也应该将它们全部创建。这个函数的返回类型为 void 。 addContentToFile： 输入字符串形式的 文件路径 和 文件内容 。如果文件不存在，你需要创建包含给定文件内容的文件。如果文件已经存在，那么你需要将给定的文件内容 追加 在原本内容的后面。这个函数的返回类型为 void 。 readContentFromFile： 输入 文件路径 ，以字符串形式返回该文件的 内容 。  ``` 示例: 输入:  ["FileSystem","ls","mkdir","addContentToFile","ls","readContentFromFile"] [[],["/"],["/a/b/c"],["/a/b/c/d","hello"],["/"],["/a/b/c/d"]] 输出: [null,[],null,null,["a"],"hello"] 解释: ```
 
●	``` 注意: 你可以假定所有文件和文件夹的路径都是绝对路径，除非是根目录 / 自身，其他路径都是以 / 开头且 不 以 / 结束。 你可以假定所有操作的参数都是有效的，即用户不会获取不存在文件的内容，或者获取不存在文件夹和文件的列表。 你可以假定所有文件夹名字和文件名字都只包含小写字母，且同一文件夹下不会有相同名字的文件夹或文件。 ```
●	600.不含连续1的非负整数
 #大厂刷题班50  #LeetCode   #Hard
●	给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 连续的1 的个数。 ``` 示例 1: 输入: 5 输出: 5 解释:  下面是带有相应二进制表示的非负整数<= 5： 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。 说明: 1 <= n <= 10^9 ```
●	LCP 03.机器人大冒险
 #大厂刷题班51  #LeetCode   #Medium
●	力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种： U: 向y轴正方向移动一格 R: 向x轴正方向移动一格。 不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。 给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。  ``` 示例 1： 输入：command = "URR", obstacles = [], x = 3, y = 2 输出：true 解释：U(0, 1) -> R(1, 1) -> R(2, 1) -> U(2, 2) -> R(3, 2)。 示例 2： 输入：command = "URR", obstacles = [[2, 2]], x = 3, y = 2 输出：false 解释：机器人在到达终点前会碰到(2, 2)的障碍物。 示例 3： 输入：command = "URR", obstacles = [[4, 2]], x = 3, y = 2 输出：true 解释：到达终点后，再碰到障碍物也不影响返回结果。   限制： 2 <= command的长度 <= 1000 command由U，R构成，且至少有一个U，至少有一个R 0 <= x <= 1e9, 0 <= y <= 1e9 0 <= obstacles的长度 <= 1000 obstacles[i]不为原点或者终点 ```
●	630.课程表 III
 #大厂刷题班51  #LeetCode    #Hard
●	这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时要完成，你将会从第 1 天开始。 给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。  ``` 示例： 输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]] 输出: 3 解释:  这里一共有 4 门课程, 但是你最多可以修 3 门: 首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。 第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。 第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。 第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。   提示: 整数 1 <= d, t, n <= 10,000 。 你不能同时修两门课程。 ```
●	642.设计搜索自动补全系统
 #大厂刷题班51  #LeetCode    #Hard
●	为搜索引擎设计一个搜索自动补全系统。用户会输入一条语句（最少包含一个字母，以特殊字符 '#' 结尾）。除 '#' 以外用户输入的每个字符，返回历史中热度前三并以当前输入部分为前缀的句子。下面是详细规则： 一条句子的热度定义为历史上用户输入这个句子的总次数。 返回前三的句子需要按照热度从高到低排序（第一个是最热门的）。如果有多条热度相同的句子，请按照 ASCII 码的顺序输出（ASCII 码越小排名越前）。 如果满足条件的句子个数少于 3，将它们全部输出。 如果输入了特殊字符，意味着句子结束了，请返回一个空集合。 你的工作是实现以下功能： ``` 构造函数： AutocompleteSystem(String[] sentences, int[] times): 这是构造函数，输入的是历史数据。 Sentences 是之前输入过的所有句子，Times 是每条句子输入的次数，你的系统需要记录这些历史信息。 现在，用户输入一条新的句子，下面的函数会提供用户输入的下一个字符： List<String> input(char c): 其中 c 是用户输入的下一个字符。字符只会是小写英文字母（'a' 到 'z' ），空格（' '）和特殊字符（'#'）。输出历史热度前三的具有相同前缀的句子。  样例 ： 操作 ： AutocompleteSystem(["i love you", "island","ironman", "i love leetcode"], [5,3,2,2]) 系统记录下所有的句子和出现的次数： "i love you" : 5 次 "island" : 3 次 "ironman" : 2 次 "i love leetcode" : 2 次 现在，用户开始新的键入： 输入 ： input('i') 输出 ： ["i love you", "island","i love leetcode"] 解释 ： 有四个句子含有前缀 "i"。其中 "ironman" 和 "i love leetcode" 有相同的热度，由于 ' ' 的 ASCII 码是 32 而 'r' 的 ASCII 码是 114，所以 "i love leetcode" 在 "ironman" 前面。同时我们只输出前三的句子，所以 "ironman" 被舍弃。 输入 ： input(' ') 输出 ： ["i love you","i love leetcode"] 解释: 只有两个句子含有前缀 "i "。 输入 ： input('a') 输出 ： [] 解释 ： 没有句子有前缀 "i a"。 输入 ： input('#') 输出 ： [] 解释 ： 用户输入结束，"i a" 被存到系统中，后面的输入被认为是下一次搜索。   注释 ： 输入的句子以字母开头，以 '#' 结尾，两个字母之间最多只会出现一个空格。 即将搜索的句子总数不会超过 100。每条句子的长度（包括已经搜索的和即将搜索的）也不会超过 100。 即使只有一个字母，输出的时候请使用双引号而不是单引号。 请记住清零 AutocompleteSystem 类中的变量，因为静态变量、类变量会在多组测试数据中保存之前结果。详情请看这里。 ```
●	875.爱吃香蕉的珂珂
 #大厂刷题班51  #LeetCode    #Hard
●	珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。 珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。   珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。 返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。  ``` 示例 1： 输入: piles = [3,6,7,11], H = 8 输出: 4 示例 2： 输入: piles = [30,11,23,4,20], H = 5 输出: 30 示例 3： 输入: piles = [30,11,23,4,20], H = 6 输出: 23   提示： 1 <= piles.length <= 10^4 piles.length <= H <= 10^9 1 <= piles[i] <= 10^9 ```
●	1035.不相交的线
 #大厂刷题班51  #LeetCode     #Medium
●	在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。 现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：  nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。 以这种方法绘制线条，并返回可以绘制的最大连线数。  ``` 示例 1： 输入：nums1 = [1,4,2], nums2 = [1,2,4] 输出：2 解释：可以画出两条不交叉的线，如上图所示。  但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。 示例 2： 输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2] 输出：3 示例 3： 输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1] 输出：2   提示： 1 <= nums1.length <= 500 1 <= nums2.length <= 500 1 <= nums1[i], nums2[i] <= 2000 ```
●	1488.避免洪水泛滥
 #大厂刷题班52  #LeetCode   #Medium
●	你的国家有无数个湖泊，所有湖泊一开始都是空的。 当第 n 个湖泊下雨的时候，如果第 n 个湖泊是空的，那么它就会装满水，否则这个湖泊会发生洪水。你的目标是避免任意一个湖泊发生洪水。 给你一个整数数组 rains ，其中： rains[i] > 0 表示第 i 天时，第 rains[i] 个湖泊会下雨。 rains[i] == 0 表示第 i 天没有湖泊会下雨，你可以选择 一个 湖泊并 抽干 这个湖泊的水。 请返回一个数组 ans ，满足： ans.length == rains.length 如果 rains[i] > 0 ，那么ans[i] == -1 。 如果 rains[i] == 0 ，ans[i] 是你第 i 天选择抽干的湖泊。 如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组 。 请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生（详情请看示例 4）。  ``` 示例 1： 输入：rains = [1,2,3,4] 输出：[-1,-1,-1,-1] 解释：第一天后，装满水的湖泊包括 [1] 第二天后，装满水的湖泊包括 [1,2] 第三天后，装满水的湖泊包括 [1,2,3] 第四天后，装满水的湖泊包括 [1,2,3,4] 没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。 示例 2： 输入：rains = [1,2,0,0,2,1] 输出：[-1,-1,2,1,-1,-1] 解释：第一天后，装满水的湖泊包括 [1] 第二天后，装满水的湖泊包括 [1,2] 第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1] 第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。 第五天后，装满水的湖泊包括 [2]。 第六天后，装满水的湖泊包括 [1,2]。 可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。 示例 3： 输入：rains = [1,2,0,1,2] 输出：[] 解释：第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。 但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。 示例 4： 输入：rains = [69,0,0,0,69] 输出：[-1,69,1,1,-1] 解释：任何形如 [-1,69,x,y,-1], [-1,x,69,y,-1] 或者 [-1,x,y,69,-1] 都是可行的解，其中 1 <= x,y <= 10^9 示例 5： 输入：rains = [10,20,20] 输出：[] 解释：由于湖泊 20 会连续下 2 天的雨，所以没有没有办法阻止洪水。   提示： 1 <= rains.length <= 10^5 0 <= rains[i] <= 10^9 ```
●	683.K 个关闭的灯泡
 #大厂刷题班52  #LeetCode    #Hard
●	N 个灯泡排成一行，编号从 1 到 N 。最初，所有灯泡都关闭。每天只打开一个灯泡，直到 N 天后所有灯泡都打开。 给你一个长度为 N 的灯泡数组 blubs ，其中 bulls[i] = x 意味着在第 (i+1) 天，我们会把在位置 x 的灯泡打开，其中 i 从 0 开始，x 从 1 开始。 给你一个整数 K ，请你输出在第几天恰好有两个打开的灯泡，使得它们中间 正好 有 K 个灯泡且这些灯泡 全部是关闭的 。 如果不存在这种情况，返回 -1 。如果有多天都出现这种情况，请返回 最小的天数 。  ``` 示例 1： 输入： bulbs: [1,3,2] K: 1 输出：2 解释： 第一天 bulbs[0] = 1，打开第一个灯泡 [1,0,0] 第二天 bulbs[1] = 3，打开第三个灯泡 [1,0,1] 第三天 bulbs[2] = 2，打开第二个灯泡 [1,1,1] 返回2，因为在第二天，两个打开的灯泡之间恰好有一个关闭的灯泡。 示例 2： 输入： bulbs: [1,2,3] k: 1 输出：-1   提示： 1 <= N <= 20000 1 <= bulbs[i] <= N bulbs 是一个由从 1 到 N 的数字构成的排列 0 <= K <= 20000 ```
●	656.金币路径
 #大厂刷题班52  #LeetCode    #Hard
●	给定一个数组 A（下标从 1 开始）包含 N 个整数：A1，A2，……，AN 和一个整数 B。你可以从数组 A 中的任何一个位置（下标为 i）跳到下标 i+1，i+2，……，i+B 的任意一个可以跳到的位置上。如果你在下标为 i 的位置上，你需要支付 Ai 个金币。如果 Ai 是 -1，意味着下标为 i 的位置是不可以跳到的。 现在，你希望花费最少的金币从数组 A 的 1 位置跳到 N 位置，你需要输出花费最少的路径，依次输出所有经过的下标（从 1 到 N）。 如果有多种花费最少的方案，输出字典顺序最小的路径。 如果无法到达 N 位置，请返回一个空数组。  ``` 样例 1 : 输入: [1,2,4,-1,2], 2 输出: [1,3,5]   样例 2 : 输入: [1,2,4,-1,2], 1 输出: []   注释 : 路径 Pa1，Pa2，……，Pan 是字典序小于 Pb1，Pb2，……，Pbm 的，当且仅当第一个 Pai 和 Pbi 不同的 i 满足 Pai < Pbi，如果不存在这样的 i 那么满足 n < m。 A1 >= 0。 A2, ..., AN （如果存在） 的范围是 [-1, 100]。 A 数组的长度范围 [1, 1000]. B 的范围 [1, 100]. ```
●	以下是大厂每周算法营养课
●	按要求调整多叉树
#2021年11月第4周
●	给定一棵多叉树的头节点head， 根据图理解题意 返回处理后的树的头节点
 
●	345.猜数字 II
#2021年11月第4周  #LeetCode    #Medium
●	我们正在玩一个猜数游戏，游戏规则如下： 我从 1 到 n 之间选择一个数字。 你来猜我选了哪个数字。 如果你猜到正确的数字，就会 赢得游戏 。 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。 给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。  ``` 示例 1： 输入：n = 10 输出：16 解释：制胜策略如下： - 数字范围是 [1,10] 。你先猜测数字为 7 。     - 如果这是我选中的数字，你的总费用为 0 。否则，你需要支付 7 。     - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。         - 如果这是我选中的数字，你的总费用为 7 。否则，你需要支付 9 。         - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 7 + 9 = $16 。         - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 7 + 9 = $16 。     - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。         - 如果这是我选中的数字，你的总费用为 7 。否则，你需要支付 3 。         - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。             - 如果这是我选中的数字，你的总费用为 7 + 3 = 10 。否则，你需要支付 5 。             - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 7 + 3 + 5 = 15 。             - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 7 + 3 + 5 = 15 。         - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。             - 如果这是我选中的数字，你的总费用为 7 + 3 = 10 。否则，你需要支付 1 。             - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 7 + 3 + 1 = 11 。 在最糟糕的情况下，你需要支付 16 。因此，你只需要 16 就可以确保自己赢得游戏。 示例 2： 输入：n = 1 输出：0 解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。 示例 3： 输入：n = 2 输出：1 解释：有两个可能的数字 1 和 2 。 - 你可以先猜 1 。     - 如果这是我选中的数字，你的总费用为 0 。否则，你需要支付 1 。     - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。 最糟糕的情况下，你需要支付 $1 。 ``` 提示： 1 <= n <= 200
●	二进制中1的个数等于target的数字个数
#2021年11月第4周
●	限制：0 <= start <= end，0 <= target <= 64 [start,end]范围上的数字，有多少数字二进制中1的个数等于target
●	城市间的最短距离
#2021年12月第1周 #单源最短路径问题
●	int n, int[][] roads, int x, int y n表示城市数量，城市编号0~n-1 roads[i][j] == distance，表示城市i到城市j距离为distance(无向图) 求城市x到城市y的最短距离
●	N步内生成最多个A
#2021年12月第1周
●	一开始屏幕上什么也没有，粘贴板里什么也没有， 你只能在键盘上做如下4种操作中的1种： 输入：在屏幕上已经显示内容的后面加一个A 全选：把屏幕上已经显示的全部内容选中 复制：被选中的内容复制进粘贴板 粘贴：在屏幕上已经显示内容的后面添加粘贴板里的内容 给定一个正数n，表示你能操作的步数， 返回n步内你能让最多多少个A显示在屏幕上
●	652.寻找重复的子树
#2021年12月第1周 #LeetCode   #Medium
●	给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 两棵树重复是指它们具有相同的结构以及相同的结点值。 ``` 示例 1： 1 / \ 2   3 /   / \ 4   2   4 / 4 下面是两个重复的子树： 2 / 4 和 4 因此，你需要以列表的形式返回上述重复子树的根结点。 ```
●	2092.找出知晓秘密的所有专家
#2021年12月第2周 #LeetCode   #Medium
●	 给你一个整数 n ，表示有 n 个专家从 0 到 n - 1 编号。另外给你一个下标从 0 开始的二维整数数组 meetings ，其中 meetings[i] = [xi, yi, timei] 表示专家 xi 和专家 yi 在时间 timei 要开一场会。一个专家可以同时参加 多场会议 。最后，给你一个整数 firstPerson 。 专家 0 有一个 秘密 ，最初，他在时间 0 将这个秘密分享给了专家 firstPerson 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 xi 在时间 timei 时知晓这个秘密，那么他将会与专家 yi 分享这个秘密，反之亦然。 秘密共享是 瞬时发生 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。 在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 任何顺序 返回答案。  ``` 示例 1： 输入：n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1 输出：[0,1,2,3,5] 解释： 时间 0 ，专家 0 将秘密与专家 1 共享。 时间 5 ，专家 1 将秘密与专家 2 共享。 时间 8 ，专家 2 将秘密与专家 3 共享。 时间 10 ，专家 1 将秘密与专家 5 共享。 因此，在所有会议结束后，专家 0、1、2、3 和 5 都将知晓这个秘密。 示例 2： 输入：n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3 输出：[0,1,3] 解释： 时间 0 ，专家 0 将秘密与专家 3 共享。 时间 2 ，专家 1 与专家 2 都不知晓这个秘密。 时间 3 ，专家 3 将秘密与专家 0 和专家 1 共享。 因此，在所有会议结束后，专家 0、1 和 3 都将知晓这个秘密。 示例 3： 输入：n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1 输出：[0,1,2,3,4] 解释： 时间 0 ，专家 0 将秘密与专家 1 共享。 时间 1 ，专家 1 将秘密与专家 2 共享，专家 2 将秘密与专家 3 共享。 注意，专家 2 可以在收到秘密的同一时间分享此秘密。 时间 2 ，专家 3 将秘密与专家 4 共享。 因此，在所有会议结束后，专家 0、1、2、3 和 4 都将知晓这个秘密。 示例 4： 输入：n = 6, meetings = [[0,2,1],[1,3,1],[4,5,1]], firstPerson = 1 输出：[0,1,2,3] 解释：时间 0 ，专家 0 将秘密与专家 1 共享。时间 0 ，专家 0 将秘密与专家 1 共享。 时间 1 ，专家 0 将秘密与专家 2 共享，专家 1 将秘密与专家 3 共享。 因此，在所有会议结束后，专家 0、1、2 和 3 都将知晓这个秘密。 ``` 提示： 2 <= n <= 10^5 1 <= meetings.length <= 10^5 meetings[i].length == 3 0 <= xi, yi <= n - 1 xi != yi 1 <= timei <= 10^5 1 <= firstPerson <= n - 1
●	黑洞的最大半径
#2021年12月第2周
●	所有黑洞的中心点记录在holes数组里 比如[[3,5] [6,9]]表示，第一个黑洞在(3,5)，第二个黑洞在(6,9) 并且所有黑洞的中心点都在左下角(0,0)，右上角(x,y)的区域里 飞船一旦开始进入黑洞，就会被吸进黑洞里 返回如果统一所有黑洞的半径，最大半径是多少， 依然能保证飞船从(0,0)能到达(x,y)
●	魔法操作下的数组最大累加和
#2021年12月第2周
●	arr数组长度为n, magic数组长度为m 比如 arr = { 3, 1, 4, 5, 7 }，如果完全不改变arr中的值， 那么收益就是累加和 = 3 + 1 + 4 + 5 + 7 = 20 magics[i] = {a,b,c} 表示arr[a~b]中的任何一个值都能改成c 并且每一种操作，都可以执行任意次，其中 0 <= a <= b < n 那么经过若干次的魔法操作，你当然可能得到arr的更大的累加和 返回arr尽可能大的累加和 n <= 10^7     m <= 10^6    arr中的值和c的范围 <= 10^12
●	多叉树上的达标路径数
#2021年12月第2周
●	给定一棵多叉树的头节点head 每个节点的颜色只会是0、1、2、3中的一种 任何两个节点之间的都有路径 如果节点a和节点b的路径上，包含全部的颜色，这条路径算达标路径 (a -> ... -> b)和(b -> ... -> a)算两条路径 求多叉树上达标的路径一共有多少？ 点的数量 <= 10^5
●	CMU入学申请考试题
#2021年12月第3周
●	给定一个长度为 N 的字符串 S，由字符'a'和'b'组成，空隙由 '?' 表示 你的任务是用a字符或b字符替换每个间隙， 替换完成后想让连续出现同一种字符的最长子串尽可能短 例如，S = "aa??bbb"， 如果将"??"替换为"aa" ，即"aaaabbb"，则由相等字符组成的最长子串长度为4 如果将"??"替换为"ba" ，即"aababbb"，则由相等字符组成的最长子串长度为3 那么方案二是更好的结果，返回3 S的长度 <= 10^6
●	循环右移二叉树
#2021年12月第3周 #腾讯音乐
●	现有一棵个节点构成的二叉树，请你将每一层的节点向右循环位移位。某层向右位移一位(即)的含义为： 1.若当前节点为左孩子节点，会变成当前节点的双亲节点的右孩子节点。 2.若当前节点为右儿子，会变成当前节点的双亲节点的右边相邻兄弟节点的左孩子节点。(如果当前节点的双亲节点已经是最右边的节点了，则会变成双亲节点同级的最左边的节点的左孩子节点) 3.该层的每一个节点同时进行一次位移。 4.是从最下面的层开始位移，位移完每一层之后，再向上，直到根节点，位移完毕。 如果从最后一层开始对该二叉树的每一层循环位移位。 ``` 以下方二叉树为例，： 1 2 3 4 5   1  / \ 2   3    / \   4   5 位移最后一层，5变成2的左孩子节点，4变成3的右孩子节点，如下图: 1 2 3 4 5     1    / \   2   3  /     \ 5       4 再位移倒数第二层，3变成1的左孩子节点，2变成1的右孩子的节点，它们的孩子节点随着一起位移，如下图： 1 2 3 4 5   1  / \ 3   2 \   /  4 5 根节点没有双亲节点，不用位移，位移完毕 现在给你这棵二叉树，请你返回循环右移位后的二叉树。 输入例子1: {1,2,3,#,#,4,5},1 输出例子1: {1,3,2,#,4,5} 例子说明1: 解释见题面描述。     输入例子2: {1,2,3,4},2 输出例子2: {1,2,3,#,#,4} 例子说明2: 1 2 3 4 5     1    / \   2   3  / 4 变为 1 2 3 4 5   1  / \ 2   3    /   4      输入例子3: {1,#,3,4,5},1 输出例子3: {1,3,#,5,4} 例子说明3: 1 2 3 4 5 1  \   3  / \ 4   5 变为 1 2 3 4 5 1  \   3  / \ 5   4 变为 1 2 3 4 5     1    /   3  / \ 5   4 ```
●	二进制取反得到最大数
#2021年12月第3周 #腾讯音乐
●	有一个二进制字符串，可以选择该串中的任意一段区间进行取反(可以进行一次或不进行)，取反指将变为，将变为。那么取反之后的可能的最大的字典序是多少呢。如有，将区间取反变为是字典序最大的。 ``` 输入例子1: "1000" 输出例子1: "1111" 例子说明1: 如题意描述。    输入例子2: "1001" 输出例子2: "1111" 例子说明2: 对区间[num_2,num_3]取反能使得字典序最大。     ```
●	k进制下一的个数
#2021年12月第3周 #腾讯音乐
●	k进制下1~m中数字出现的次数，记作F(m,k)。例如F(5,3)=5，因为三进制1~5为{1,2,10,11,12}，数字1出现了5次。    在k进制下，最小多小的num，可以让1~num范围的数拥有1的个数不少于n个
●	高尔夫球场里的砍树问题
#2021年12月第3周
●	你被请来给一个要举办高尔夫比赛的树林砍树，树林由一个 m x n 的矩阵表示， 在这个矩阵中： 0 表示障碍，无法触碰 1 表示地面，可以行走 比 1 大的数 表示有树的单元格，可以行走，数值表示树的高度 每一步，你都可以向上、下、左、右四个方向之一移动一个单位， 如果你站的地方有一棵树，那么你可以决定是否要砍倒它。 你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 1（即变为地面）。 你将从 (0, 0) 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。 可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。
●	合法路径的代表集合数量
#2021年12月第4周 #美团
●	给定一个无向图 从任何一个点x出发，比如有一条路径: x -> a -> b -> c -> y 这条路径上有5个点并且5个点都不一样的话，我们说(x,a,b,c,y)是一条合法路径 这条合法路径的代表，就是x,a,b,c,y所组成的集合，我们叫做代表集合 如果从b到y，还有一条路径叫(b,a,c,x,y)，那么(x,a,b,c,y)和(b,a,c,x,y)是同一个代表集合 返回这个无向图中所有合法路径的代表集合数量 题目给定点的数量n <= 15，边的数量m <= 60 所有的点编号都是从0~n-1的
●	同级地域合并
#2021年12月第4周
●	class AreaResource { String area; // area表示的是地区全路径,最多可能有6级，比如： 中国,四川,成都  或者  中国,浙江,杭州 String spliter; // 比如：逗号 -> , long count; // 表示地区的门店数量 } 现在需要把  List<AreaResource> 进行转换，需要做到同级的地域能合并 比如：area为中国,四川,成都 ，有10个门店；area为中国,浙江,杭州，有25个门店；area为中国,浙江,义乌，有22个门店 最终生成的JSON字符串为：  {"中国":{"四川":{"成都":10]},"浙江":{"义乌":22,"杭州":25}}} 请实现下面的方法 public String mergeCount(List<AreaResource> areas)
●	钝角三角形的数量
 #2021年12月第4周 #hulu
●	有一个以原点为圆心，半径为1的圆 在这个圆的圆周上，有一些点 因为所有的点都在圆周上，所以每个点可以有很简练的表达 比如：用0来表示一个圆周上的点，这个点就在(1,0)位置 比如：用6000来表示一个点，这个点是(1,0)点沿着圆周逆时针转60.00度之后所在的位置 比如：用18034来表示一个点，这个点是(1,0)点沿着圆周逆时针转180.34度之后所在的位置 这样一来，所有的点都可以用[0, 36000)范围上的数字来表示 那么任意三个点都可以组成一个三角形，返回能组成钝角三角形的数量
●	851.喧闹和富有
#2021年12月第5周
●	有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 "person x "。给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自洽（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自洽（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。  ``` 示例 1： 输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] 输出：[5,5,2,5,4,5,6,7] 解释：  answer[0] = 5， person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。 唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7， 但是目前还不清楚他是否比 person 0 更有钱。 answer[7] = 7， 在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7）， 最安静（有较低安静值 quiet[x]）的人是 person 7。 其他的答案也可以用类似的推理来解释。 示例 2： 输入：richer = [], quiet = [0] 输出：[0]   提示： n == quiet.length 1 <= n <= 500 0 <= quiet[i] < n quiet 的所有值 互不相同 0 <= richer.length <= n * (n - 1) / 2 0 <= ai, bi < n ai != bi richer 中的所有数对 互不相同 对 richer 的观察在逻辑上是一致的 ```
●	完成任务的天数
#2021年12月第5周 #hulu
●	有n个人，m个任务，任务之间有依赖记录在int[][] depends里 比如: depends[i] = [a, b]，表示a任务依赖b任务的完成 其中 0 <= a < m，0 <= b < m 1个人1天可以完成1个任务，每个人都会选当前能做任务里，标号最小的任务 一个任务所依赖的任务都完成了，该任务才能开始做 返回n个人做完m个任务，需要几天
●	求最少需要的面试官数量
#2021年12月第5周 #华为
●	某公司组织一场公开招聘活动，假设由于人数和场地的限制，每人每次面试的时长不等，并已经安排给定，用(S1,E1)、(S2,E2)、(Sj,Ej)...(Si < Ei，均为非负整数)表示每场面试的开始和结束时间。面试采用一对一的方式，即一名面试官同时只能面试一名应试者，一名面试官完成一次面试后可以立即进行下一场面试，且每个面试官的面试人次不超过m。为了支撑招聘活动高效顺利进行，请你计算至少需要多少名面试官。为了支撑招聘活动高效顺利进行，请你计算至少需要多少名面试官。 输入描述：输入的第一行为面试官的最多面试人次m，第二行为当天总的面试场次n，接下来的n行为每场面试的起始时间和结束时间，起始时间和结束时间用空格分隔。输入的第一行为面试官的最多面试人次m，第二行为当天总的面试场次n，接下来的n行为每场面试的起始时间和结束时间，起始时间和结束时间用空格分隔。 其中，1 <= n, m <= 500 输出一个整数，表示至少需要的面试官数量。 ``` 示例1： 2 4 1 2 3 5 4 7 6 8 输出：2 ```
●	摆放砖块
#2021年12月第5周 #hulu
●	你只有`1*1、1*2、1*3、1*4`，四种规格的砖块你想铺满n行m列的区域，规则如下：你想铺满n行m列的区域，规则如下： ``` 1）不管那种规格的砖，都只能横着摆       比如1*3这种规格的砖，3长度是水平方向，1长度是竖直方向 2）会有很多方法铺满整个区域，整块区域哪怕有一点点不一样，就算不同的方法 3）区域内部(不算区域整体的4条边界)，不能有任何砖块的边界线（从上一直贯穿到下） 返回符合三条规则下，铺满n行m列的区域，有多少种不同的摆放方法
●	尽可能的短的剩余字符串
#2022年1月第1周  #阿里
●	str中"ab"和"ba"子串都可以消除，消除之后剩下字符会重新靠在一起，继续出现可以消除的子串...你的任务是决定一种消除的顺序，最后让str消除到尽可能的短返回尽可能的短的剩余字符串
●	913.猫和老鼠
#2022年1月第1周 #LeetCode   #Medium #业务限制模型
●	两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。 老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。此外，猫无法移动到洞中（节点 0）。此外，猫无法移动到洞中（节点 0）。 然后，游戏在出现以下三种情形之一时结束： 如果猫和老鼠出现在同一个节点，猫获胜。 如果老鼠到达洞中，老鼠获胜。 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。 给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：如果老鼠获胜，则返回 1；如果老鼠获胜，则返回 1； 如果猫获胜，则返回 2； 如果平局，则返回 0 。
●	示例 1：  ``` 输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] 输出：0 ```
 
●	示例 2：  ``` 输入：graph = [[1,3],[0],[3],[0,2]] 输出：1   提示： 3 <= graph.length <= 50 1 <= graph[i].length < graph.length 0 <= graph[i][j] < graph.length graph[i][j] != i graph[i] 互不相同 猫和老鼠在游戏中总是移动 ```
 
●	1770.执行乘法运算的最大分数
#2022年1月第1周   #LeetCode   #Medium #样本对应模型
●	给你两个长度分别 n 和 m 的整数数组 nums 和 multipliers ，其中 n >= m ，数组下标 从 1 开始 计数。 初始时，你的分数为 0 。你需要执行恰好 m 步操作。在第 i 步操作（从 1 开始 计数）中，需要： 选择数组 nums 开头处或者末尾处 的整数 x 。 你获得 multipliers[i] * x 分，并累加到你的分数中。 将 x 从数组 nums 中移除。 在执行 m 步操作后，返回 最大 分数。  ``` 示例 1： 输入：nums = [1,2,3], multipliers = [3,2,1] 输出：14 解释：一种最优解决方案如下： - 选择末尾处的整数 3 ，[1,2,3] ，得 3 * 3 = 9 分，累加到分数中。 - 选择末尾处的整数 2 ，[1,2] ，得 2 * 2 = 4 分，累加到分数中。  总分数为 9 + 4 + 1 = 14 。总分数为 9 + 4 + 1 = 14 。 示例 2： 输入：nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6] 输出：102 解释：一种最优解决方案如下： - 选择开头处的整数 -5 ，[-5,-3,-3,-2,7,1] ，得 -5 * -10 = 50 分，累加到分数中。- 选择开头处的整数 -3 ，[-3,-3,-2,7,1] ，得 -3 * -5 = 15 分，累加到分数中。- 选择开头处的整数 -3 ，[-3,-3,-2,7,1] ，得 -3 * -5 = 15 分，累加到分数中。 - 选择开头处的整数 -3 ，[-3,-2,7,1] ，得 -3 * 3 = -9 分，累加到分数中。 - 选择末尾处的整数 1 ，[-2,7,1] ，得 1 * 4 = 4 分，累加到分数中。 - 选择末尾处的整数 7 ，[-2,7] ，得 7 * 6 = 42 分，累加到分数中。 总分数为 50 + 15 - 9 + 4 + 42 = 102 。   提示： n == nums.length m == multipliers.length 1 <= m <= 103 m <= n <= 105 -1000 <= nums[i], multipliers[i] <= 1000 ```
●	从左上角走到右下角的最短距离
#2022年1月第1周 #单源最短路径问题 #Dijkstra
●	给定一个二维数组，其中全是非负数 每一步都可以往上、下、左、右四个方向运动走过的路径, 会沿途累加数字, 返回从左上角走到右下角的最短距离
●	多线程统计单词数量
#2022年1月第2周
●	给定一个非常大的List<String> list 每一个字符串类似 : "hello,world,have,hello,world" 这一个字符串中，有2个hello，2个world，1个have 请设计一种多线程处理方案，统计list中每一个字符串，切分出来的单词数量，并且汇总 最终返回一个HashMap<String, Integer>表示每个字符串在list中一共出现几次 多线程设计 + 算法 本题没有代码实现，会在课上讲述思路
●	所有砖块最多摆几层
#2022年1月第2周 #华为
●	给定一个正数数组arr，其中每个值代表砖块长度 所有砖块等高等宽，只有长度有区别 每一层可以用1块或者2块砖来摆 要求每一层的长度一样 要求必须使用所有的砖块 请问最多摆几层
●	二进制和16进制的字符串
#2022年1月第2周 #兴业数金
●	给定一个字符串形式的数，比如"3421"或者"-8731" 如果这个数不在-32768~32767范围上，那么返回"NODATA" 如果这个数在-32768~32767范围上，那么这个数就没有超过16个二进制位所能表达的范围 返回这个数的2进制形式的字符串和16进制形式的字符串，用逗号分割
●	2111.使数组K递增的最少操作次数
#2022年1月第2周 #K递增子序列  #LeetCode   #Hard
●	给你一个下标从 0 开始包含 n 个正整数的数组 arr ，和一个正整数 k 。 如果对于每个满足 k <= i <= n-1 的下标 i ，都有 arr[i-k] <= arr[i] ，那么我们称 arr 是 K 递增 的。 比方说，arr = [4, 1, 5, 2, 6, 2] 对于 k = 2 是 K 递增的，因为： arr[0] <= arr[2] (4 <= 5) arr[1] <= arr[3] (1 <= 2) arr[2] <= arr[4] (5 <= 6) arr[3] <= arr[5] (2 <= 2) 但是，相同的数组 arr 对于 k = 1 不是 K 递增的（因为 arr[0] > arr[1]），对于 k = 3 也不是 K 递增的（因为 arr[0] > arr[3] ）。 每一次 操作 中，你可以选择一个下标 i 并将 arr[i] 改成任意 正整数。 请你返回对于给定的 k ，使数组变成 K 递增的 最少操作次数 。  ``` 示例 1： 输入：arr = [5,4,3,2,1], k = 1 输出：4 解释： 对于 k = 1 ，数组最终必须变成非递减的。 可行的 K 递增结果数组为 [5,6,7,8,9]，[1,1,1,1,1]，[2,2,3,4,4] 。它们都需要 4 次操作。 次优解是将数组变成比方说 [6,7,8,9,10] ，因为需要 5 次操作。 显然我们无法使用少于 4 次操作将数组变成 K 递增的。 示例 2： 输入：arr = [4,1,5,2,6,2], k = 2 输出：0 解释： 这是题目描述中的例子。 对于每个满足 2 <= i <= 5 的下标 i ，有 arr[i-2] <= arr[i] 。 由于给定数组已经是 K 递增的，我们不需要进行任何操作。 示例 3： 输入：arr = [4,1,5,2,6,2], k = 3 输出：2 解释： 下标 3 和 5 是仅有的 3 <= i <= 5 且不满足 arr[i-3] <= arr[i] 的下标。 将数组变成 K 递增的方法之一是将 arr[3] 变为 4 ，且将 arr[5] 变成 5 。 数组变为 [4,1,5,4,6,5] 。 可能有其他方法将数组变为 K 递增的，但没有任何一种方法需要的操作次数小于 2 次。   提示： 1 <= arr.length <= 10^5 1 <= arr[i], k <= arr.length
●	魔法操作后的数组最大和
#2022年1月第2周 #美团
●	小美有一个长度为n的数组， 为了使得这个数组的和尽量大，她向会魔法的小团进行求助 小团可以选择数组中至多两个不相交的子数组， 并将区间里的数全都变为原来的10倍 小团想知道他的魔法最多可以帮助小美将数组的和变大到多少?
●	插班生和安静值
#2022年1月第2周
●	给定一个非负数组arr，学生依次坐在0~N-1位置，每个值表示学生的安静值 如果在i位置安置插班生，那么i位置的安静值变成0，同时任何同学都会被影响到而减少安静值 同学安静值减少的量: N - 这个同学到插班生的距离 但是减到0以下的话，当做0处理 返回一个和arr等长的ans数组，ans[i]表示如果把插班生安排在i位置，所有学生的安静值的和 比如 : arr = {3,4,2,1,5}，应该返回{4,3,2,3,4} 比如 : arr = {10,1,10,10,10}，应该返回{24,27,20,20,22} arr长度 <= 10^5 arr中值 <= 2 * 10^5 注意：本题在直播课上讲错了，已经发了重新录制的视频，请一定要看更正后的视频
●	A*算法
#2022年1月第3周
●	过程和Dijskra高度相处 有到终点的预估函数 只要预估值<=客观上最优距离，就是对的 预估函数是一种吸引力：     1）合适的吸引力可以提升算法的速度   2）吸引力“过强”会出现错误
●	相对于BFS、Dijkstra 等算法，A*搜寻算法作为一种高效的最短路径搜索算法，如今，已得到日益广泛的应用。 初步了解A*搜寻算法的高效及与其它最短路径算法的比较，请参考此文：A*，Dijkstra，BFS算法性能比较及A*算法的应用。
●	1036. 逃离大迷宫
#2022年1月第3周 #BFS
●	在一个 10^6 x 10^6 的网格中，每个网格上方格的坐标为 (x, y) 。 现在从源方格 source = [sx, sy] 开始出发，意图赶往目标方格 target = [tx, ty] 。数组 blocked 是封锁的方格列表，其中每个 blocked[i] = [xi, yi] 表示坐标为 (xi, yi) 的方格是禁止通行的。 每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 不 在给出的封锁列表 blocked 上。同时，不允许走出网格。 只有在可以通过一系列的移动从源方格 source 到达目标方格 target 时才返回 true。否则，返回 false。  ``` 示例 1： 输入：blocked = [[0,1],[1,0]], source = [0,0], target = [0,2] 输出：false 解释： 从源方格无法到达目标方格，因为我们无法在网格中移动。 无法向北或者向东移动是因为方格禁止通行。 无法向南或者向西移动是因为不能走出网格。 示例 2： 输入：blocked = [], source = [0,0], target = [999999,999999] 输出：true 解释： 因为没有方格被封锁，所以一定可以到达目标方格。   提示： 0 <= blocked.length <= 200 blocked[i].length == 2 0 <= xi, yi < 10^6 source.length == target.length == 2 0 <= sx, sy, tx, ty < 1^6 source != target 题目数据保证 source 和 target 不在封锁列表内 ```
●	累加和>=k的所有子数组中的最短长度
#2022年1月第3周 #字节
●	给定一个数组arr，其中的值有可能正、负、0 给定一个正数k 返回累加和>=k的所有子数组中，最短的子数组长度
●	购物单
#2022年1月第4周
●	things是一个N*3的二维数组，商品有N件，商品编号从1~N 比如things[3] = [300, 2, 6] 代表第3号商品：价格300，重要度2，它是6号商品的附属商品 再比如things[6] = [500, 3, 0] 代表第6号商品：价格500，重要度3，它不是任何附属，它是主商品 每件商品的收益是价格*重要度，花费就是价格 如果一个商品是附属品，那么只有它附属的主商品购买了，它才能被购买 任何一个附属商品，只会有1个主商品 任何一个主商品的附属商品数量，不会超过2件 主商品和附属商品的层级最多有2层 给定二维数组things、钱数money，返回整体花费不超过money的情况下，最大的收益总和
●	最小的总扣分量
#2022年1月第4周 #美团
●	小团去参加军训，军训快要结束了，长官想要把大家一排n个人分成m组，然后让每组分别去参加阅兵仪式 只能选择相邻的人一组，不能随意改变队伍中人的位置 阅兵仪式上会进行打分，其中有一个奇怪的扣分点是每组的最大差值，即每组最大值减去最小值 长官想要让这分成的m组总扣分量最小，即这m组分别的极差之和最小 长官正在思索如何安排中，就让小团来帮帮他吧
●	419.甲板上的战舰
#2022年1月第4周 #LeetCode   #Medium #米哈游
●	给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 'X' 或者是一个空位 '.' ，返回在甲板 board 上放置的 战舰 的数量。 战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。  ``` 示例 1： 输入：board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]] 输出：2 示例 2： 输入：board = [["."]] 输出：0   提示： m == board.length n == board[i].length 1 <= m, n <= 200 board[i][j] 是 '.' 或 'X' ``` 进阶：你可以实现一次扫描算法，并只使用 O(1) 额外空间，并且不修改 board 的值来解决这个问题吗？
●	710.黑名单中的随机数
#2022年1月第4周 #LeetCode   #Hard
●	给定一个包含 [0，n) 中不重复整数的黑名单 blacklist ，写一个函数从 [0, n) 中返回一个不在 blacklist 中的随机整数。 对它进行优化使其尽量少调用系统方法 Math.random() 。 提示: 1 <= n <= 1000000000 0 <= blacklist.length < min(100000, N) [0, n) 不包含 n ，详细参见 interval notation 。 示例 1： 输入： ["Solution","pick","pick","pick"] [[1,[]],[],[],[]] 输出：[null,0,0,0] 示例 2： 输入： ["Solution","pick","pick","pick"] [[2,[]],[],[],[]] 输出：[null,1,1,1] 示例 3： 输入： ["Solution","pick","pick","pick"] [[3,[1]],[],[],[]] 输出：[null,0,0,2] 示例 4： 输入：  ["Solution","pick","pick","pick"] [[4,[2]],[],[],[]] 输出：[null,1,3,1] 输入语法说明： 输入是两个列表：调用成员函数名和调用的参数。Solution的构造函数有两个参数，n 和黑名单 blacklist。pick 没有参数，输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。
●	679.24 点游戏
#2022年2月第2周 #LeetCode   #Hard
●	给定一个长度为4的整数数组 cards 。你有 4 张卡片，每张卡片上都包含一个范围在 [1,9] 的数字。您应该使用运算符 ['+', '-', '*', '/'] 和括号 '(' 和 ')' 将这些卡片上的数字排列成数学表达式，以获得值24。 你须遵守以下规则: 除法运算符 '/' 表示实数除法，而不是整数除法。 例如， 4 /(1 - 2 / 3)= 4 /(1 / 3)= 12 。 每个运算都在两个数字之间。特别是，不能使用 “-” 作为一元运算符。例如，如果 cards =[1,1,1,1] ，则表达式 “-1 -1 -1 -1” 是 不允许 的。例如，如果 cards =[1,1,1,1] ，则表达式 “-1 -1 -1 -1” 是 不允许 的。 你不能把数字串在一起例如，如果 cards =[1,2,1,2] ，则表达式 “12 + 12” 无效。例如，如果 cards =[1,2,1,2] ，则表达式 “12 + 12” 无效。 如果可以得到这样的表达式，其计算结果为 24 ，则返回 true ，否则返回 false 。   示例 1: 输入: cards = [4, 1, 8, 7] 输出: true 解释: (8-4) * (7-1) = 24 示例 2: 输入: cards = [1, 2, 1, 2] 输出: false   提示: cards.length == 4 1 <= cards[i] <= 9
●	719.找出第 k 小的距离对
#2022年2月第2周 #LeetCode   #Hard #二分法
●	给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。 ``` 示例 1: 输入： nums = [1,3,1] k = 1 输出：0  解释： 所有数对如下： (1,3) -> 2 (1,1) -> 0 (3,1) -> 2 因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。 提示: 2 <= len(nums) <= 10000. 0 <= nums[i] < 1000000. 1 <= k <= len(nums) * (len(nums) - 1) / 2. ```
●	2166.设计位集
#2022年2月第2周 #LeetCode    #Medium
●	位集 Bitset 是一种能以紧凑形式存储位的数据结构。 请你实现 Bitset 类。 - Bitset(int size) 用 size 个位初始化 Bitset ，所有位都是 0 。 - void fix(int idx) 将下标为 idx 的位上的值更新为 1 。如果值已经是 1 ，则不会发生任何改变。 - void unfix(int idx) 将下标为 idx 的位上的值更新为 0 。如果值已经是 0 ，则不会发生任何改变。 - void flip() 翻转 Bitset 中每一位上的值。换句话说，所有值为 0 的位将会变成 1 ，反之亦然。 - boolean all() 检查 Bitset 中 每一位 的值是否都是 1 。如果满足此条件，返回 true ；否则，返回 false 。 - boolean one() 检查 Bitset 中 是否 至少一位 的值是 1 。如果满足此条件，返回 true ；否则，返回 false 。 - int count() 返回 Bitset 中值为 1 的位的 总数 。 - String toString() 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 i 个下标处的字符应该与 Bitset 中的第 i 位一致。   示例： 输入 ["Bitset", "fix", "fix", "flip", "all", "unfix", "flip", "one", "unfix", "count", "toString"] [[5], [3], [1], [], [], [0], [], [], [0], [], []] 输出 [null, null, null, null, false, null, null, true, null, 2, "01010"] 解释 Bitset bs = new Bitset(5); // bitset = "00000". bs.fix(3);     // 将 idx = 3 处的值更新为 1 ，此时 bitset = "00010" 。 bs.fix(1);     // 将 idx = 1 处的值更新为 1 ，此时 bitset = "01010" 。 bs.flip();     // 翻转每一位上的值，此时 bitset = "10101" 。 bs.all();      // 返回 False ，bitset 中的值不全为 1 。 bs.unfix(0);   // 将 idx = 0 处的值更新为 0 ，此时 bitset = "00101" 。 bs.flip();     // 翻转每一位上的值，此时 bitset = "11010" 。 bs.one();      // 返回 True ，至少存在一位的值为 1 。 bs.unfix(0);   // 将 idx = 0 处的值更新为 0 ，此时 bitset = "01010" 。 bs.count();    // 返回 2 ，当前有 2 位的值为 1 。 bs.toString(); // 返回 "01010" ，即 bitset 的当前组成情况。   提示： 1 <= size <= 10^5 0 <= idx <= size - 1
●	780. 到达终点
#2022年2月第2周 #LeetCode   #Hard
●	给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的转换可以从起点 (sx, sy) 到达终点 (tx, ty)，则返回 true，否则返回 false。 从点 (x, y) 可以转换到 (x, x+y)  或者 (x+y, y)。  ``` 示例 1: 输入: sx = 1, sy = 1, tx = 3, ty = 5 输出: true 解释: 可以通过以下一系列转换从起点转换到终点： (1, 1) -> (1, 2) (1, 2) -> (3, 2) (3, 2) -> (3, 5) 示例 2: 输入: sx = 1, sy = 1, tx = 2, ty = 2  输出: false 示例 3: 输入: sx = 1, sy = 1, tx = 1, ty = 1  输出: true   提示: 1 <= sx, sy, tx, ty <= 10^9 ```
●	2122.还原原数组
#2022年2月第2周 #LeetCode    #Medium
●	Alice 有一个下标从 0 开始的数组 arr ，由 n 个正整数组成。她会选择一个任意的 正整数 k 并按下述方式创建两个下标从 0 开始的新整数数组 lower 和 higher ： 1. 对每个满足 0 <= i < n 的下标 i ，lower[i] = arr[i] - k 2. 对每个满足 0 <= i < n 的下标 i ，higher[i] = arr[i] + k 不幸地是，Alice 丢失了全部三个数组。但是，她记住了在数组 lower 和 higher 中出现的整数，但不知道每个整数属于哪个数组。请你帮助 Alice 还原原数组。 给你一个由 2n 个整数组成的整数数组 nums ，其中 恰好 n 个整数出现在 lower ，剩下的出现在 higher ，还原并返回 原数组 arr 。如果出现答案不唯一的情况，返回 任一 有效数组。 注意：生成的测试用例保证存在 至少一个 有效数组 arr 。  ``` 示例 1： 输入：nums = [2,10,6,4,8,12] 输出：[3,7,11] 解释： 如果 arr = [3,7,11] 且 k = 1 ，那么 lower = [2,6,10] 且 higher = [4,8,12] 。 组合 lower 和 higher 得到 [2,6,10,4,8,12] ，这是 nums 的一个排列。 另一个有效的数组是 arr = [5,7,9] 且 k = 3 。在这种情况下，lower = [2,4,6] 且 higher = [8,10,12] 。 示例 2： 输入：nums = [1,1,3,3] 输出：[2,2] 解释： 如果 arr = [2,2] 且 k = 1 ，那么 lower = [1,1] 且 higher = [3,3] 。 组合 lower 和 higher 得到 [1,1,3,3] ，这是 nums 的一个排列。 注意，数组不能是 [1,3] ，因为在这种情况下，获得 [1,1,3,3] 唯一可行的方案是 k = 0 。 这种方案是无效的，k 必须是一个正整数。 示例 3： 输入：nums = [5,435] 输出：[220] 解释： 唯一可行的组合是 arr = [220] 且 k = 215 。在这种情况下，lower = [5] 且 higher = [435] 。   提示： 2 * n == nums.length 1 <= n <= 1000 1 <= nums[i] <= 10^9 生成的测试用例保证存在 至少一个 有效数组 arr ```
●	787.K 站中转内最便宜的航班
#2022年2月第3周 #LeetCode    #Medium #Bellman-Ford  #单源最短路径
●	有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。  ``` 示例 1： 输入:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 输出: 200 解释:  城市航班图如下
 
●	 ``` 从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。 ``` 示例 2： 输入:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 输出: 500 解释:  城市航班图如下
 
●	 ``` 从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。   ``` 提示： 1 <= n <= 100 0 <= flights.length <= (n * (n - 1) / 2) flights[i].length == 3 0 <= fromi, toi < n fromi != toi 1 <= pricei <= 10^4 航班没有重复，且不存在自环 0 <= src, dst, k < n src != dst
 
●	1553.吃掉 N 个橘子的最少天数
#2022年2月第3周 #LeetCode  #Hard #腾讯  #贪心
●	厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子： 吃掉一个橘子。 如果剩余橘子数 n 能被 2 整除，那么你可以吃掉 n/2 个橘子。 如果剩余橘子数 n 能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。 每天你只能从以上 3 种方案中选择一种方案。 请你返回吃掉所有 n 个橘子的最少天数。  ``` 示例 1： 输入：n = 10 输出：4 解释：你总共有 10 个橘子。 第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。 第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除） 第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。 第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。 你需要至少 4 天吃掉 10 个橘子。 示例 2： 输入：n = 6 输出：3 解释：你总共有 6 个橘子。 第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除） 第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除） 第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。 你至少需要 3 天吃掉 6 个橘子。 示例 3： 输入：n = 1 输出：1 示例 4： 输入：n = 56 输出：6   提示： 1 <= n <= 2*10^9 ```
●	1041.困于环中的机器人
#2022年2月第3周 #LeetCode    #Medium
●	在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。机器人可以接受下列三条指令之一： "G"：直走 1 个单位 "L"：左转 90 度 "R"：右转 90 度 机器人按顺序执行指令 instructions，并一直重复它们。 只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。  ``` 示例 1： 输入："GGLLGG" 输出：true 解释： 机器人从 (0,0) 移动到 (0,2)，转 180 度，然后回到 (0,0)。 重复这些指令，机器人将保持在以原点为中心，2 为半径的环中进行移动。 示例 2： 输入："GG" 输出：false 解释： 机器人无限向北移动。 示例 3： 输入："GL" 输出：true 解释： 机器人按 (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ... 进行移动。   提示： 1 <= instructions.length <= 100 instructions[i] 在 {'G', 'L', 'R'} 中 ```
●	正好等于k个的最多组数
#2022年2月第3周 #微软 #动态规划
●	给定一个数组arr，一个正数num，一个正数k 可以把arr中的某些数字拿出来组成一组，要求该组中的最大值减去最小值<=num 且该组数字的个数一定要正好等于k 每个数字只能选择进某一组，不能进多个组 返回arr中最多有多少组
●	2029.石子游戏 IX
#2022年2月第3周 #LeetCode  #Hard #博弈论
●	Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。 Alice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。 如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。 如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。 假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。  ``` 示例 1： 输入：stones = [2,1] 输出：true 解释：游戏进行如下： - 回合 1：Alice 可以移除任意一个石子。 - 回合 2：Bob 移除剩下的石子。  已移除的石子的值总和为 1 + 2 = 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。 示例 2： 输入：stones = [2] 输出：false 解释：Alice 会移除唯一一个石子，已移除石子的值总和为 2 。  由于所有石子都已移除，且值总和无法被 3 整除，Bob 获胜。 示例 3： 输入：stones = [5,1,2,4,3] 输出：false 解释：Bob 总会获胜。其中一种可能的游戏进行方式如下： - 回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。 - 回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 = 1 + 3 = 4 。 - 回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 = 1 + 3 + 4 = 8 。 - 回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 = 10. - 回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 + 5 = 15. Alice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜。   提示： 1 <= stones.length <= 10^5 1 <= stones[i] <= 10^4 ```
●	相同数量的的划分
#2022年2月第4周 #微软
●	比如，str = "ayxbx" 有以下4种切法 : a | yxbx、ay | xbx、ayx | bx、ayxb | x 其中第1、3、4种切法符合：x和y的个数，至少在左右两块中的一块里有相同的数量 所以返回3 给定一个字符串str，长度为N 你有N-1种划分方法，把str切成左右两半，返回有几种切法满足： x和y的个数，至少在左右两块中的一块里有相同的数量
●	最小的达标数字
#2022年2月第4周 #微软
●	给定一个正数num，要返回一个大于num的数，   并且每一位和相邻位的数字不能相等   返回达标的数字中，最小的那个
●	1043.分隔数组以得到最大和
#2022年2月第4周  #LeetCode   #Medium
●	给你一个整数数组 arr，请你将该数组分隔为长度最多为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。 返回将数组分隔变换后能够得到的元素最大和。  注意，原数组和分隔后的数组对应顺序应当一致，也就是说，你只能选择分隔数组的位置而不能调整数组中的顺序。   ``` 示例 1： 输入：arr = [1,15,7,9,2,5,10], k = 3 输出：84 解释： 因为 k=3 可以分隔成 [1,15,7] [9] [2,5,10]，结果为 [15,15,15,9,10,10,10]，和为 84，是该数组所有分隔变换后元素总和最大的。 若是分隔成 [1] [15,7,9] [2,5,10]，结果就是 [1, 15, 15, 15, 10, 10, 10] 但这种分隔方式的元素总和（76）小于上一种。  示例 2： 输入：arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4 输出：83 示例 3： 输入：arr = [1], k = 1 输出：1   提示： 1 <= arr.length <= 500 0 <= arr[i] <= 10^9 1 <= k <= arr.length ```
●	所有的降序三元组数量
#2022年2月第4周 #indextree #最长递增子序列 #有序表
●	返回一个数组中，所有降序三元组的数量 比如 : {5, 3, 4, 2, 1} 所有降序三元组为 :  {5, 3, 2}、{5, 3, 1}、{5, 4, 2}、{5, 4, 1}、{5, 2, 1}、{3, 2, 1}、{4, 2, 1} 所以返回数量7
●	2157.字符串分组
#2022年2月第4周  #LeetCode   #Hard
●	给你一个下标从 0 开始的字符串数组 words 。每个字符串都只包含 小写英文字母 。words 中任意一个子串中，每个字母都至多只出现一次。 如果通过以下操作之一，我们可以从 s1 的字母集合得到 s2 的字母集合，那么我们称这两个字符串为 关联的 ： 往 s1 的字母集合中添加一个字母。 从 s1 的字母集合中删去一个字母。 将 s1 中的一个字母替换成另外任意一个字母（也可以替换为这个字母本身）。 数组 words 可以分为一个或者多个无交集的 组 。如果一个字符串与另一个字符串关联，那么它们应当属于同一个组。 注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。 请你返回一个长度为 2 的数组 ans ： ans[0] 是 words 分组后的 总组数 。 ans[1] 是字符串数目最多的组所包含的字符串数目。  ``` 示例 1： 输入：words = ["a","b","ab","cde"] 输出：[2,3] 解释： - words[0] 可以得到 words[1] （将 'a' 替换为 'b'）和 words[2] （添加 'b'）。所以 words[0] 与 words[1] 和 words[2] 关联。 - words[1] 可以得到 words[0] （将 'b' 替换为 'a'）和 words[2] （添加 'a'）。所以 words[1] 与 words[0] 和 words[2] 关联。 - words[2] 可以得到 words[0] （删去 'b'）和 words[1] （删去 'a'）。所以 words[2] 与 words[0] 和 words[1] 关联。 - words[3] 与 words 中其他字符串都不关联。 所以，words 可以分成 2 个组 ["a","b","ab"] 和 ["cde"] 。最大的组大小为 3 。 示例 2： 输入：words = ["a","ab","abc"] 输出：[1,3] 解释： - words[0] 与 words[1] 关联。 - words[1] 与 words[0] 和 words[2] 关联。 - words[2] 与 words[1] 关联。 由于所有字符串与其他字符串都关联，所以它们全部在同一个组内。 所以最大的组大小为 3 。   提示： 1 <= words.length <= 2 * 10^4 1 <= words[i].length <= 26 words[i] 只包含小写英文字母。 words[i] 中每个字母最多只出现一次。 ```
●	强连通分量
#2022年3月第1周  #强连通分量
●	## 强连通分量的原理   1，理解什么是dfn序号   2，理解什么是low序号   3，理解算法流程中，节点的三种状态：未遍历、遍历了未结算、遍历了已结算   4，理解什么是scc序号    ## tarjan(cur)算法求强连通分量流程：   1，遍历到一个“未遍历”状态的节点cur   2，给cur节点dfn编号和low编号，初始时low(cur) = dfn(cur)    3，将cur标记为“遍历了未结算”状态，并放入栈中   4，对于cur的每个孩子q，做如下两步操作：         1）如果q未遍历，执行tarjen(u)；否则，不执行tarjan(u)         2）步骤1)后，q就遍历过了，如果是“遍历未结算”，令low(cur) = min ( low(cur), low(q))；                               如果是“已结算”，什么也不做   5，如果经历完步骤4，依然发现low(cur) = dfn(cur)，         说明cur是一个强连通分量的头节点，分配给cur一个scc号，         并去结算cur及其cur之下的点(利用栈)
●	学校间传输软件
#2022年3月第1周  #强连通分量
●	N个学校之间有单向的网络，每个学校得到一套软件后，   可以通过单向网络向周边的学校传输   问题1：   初始至少需要向多少个学校发放软件，使得网络内所有的学校最终都能得到软件   问题2：   至少需要添加几条传输线路(边)，使任意向一个学校发放软件后，   经过若干次传送，网络内所有的学校最终都能得到软件   2 <= N <= 1000
●	红人的总数
#2022年3月第1周  #强连通分量
●	A -> B，表示A认为B是红人   A -> B -> C，表示A认为B是红人，B认为C是红人，   规定“认为”关系有传递性，所以A也认为C是红人   给定一张有向图，方式是给定M个有序对(A, B)    (A, B)表示A认为B是红人，该关系具有传递性   给定的有序对中可能包含(A, B)和(B, C)，但不包含(A,C)   求被其他所有人认为是红人的总数
●	炸弹的最少引爆次数
#2022年3月第1周  #强连通分量
●	在一个地图上有若干个炸弹，每个炸弹会呈现十字型引爆 每个炸弹都有其当量值，这个值决定了这个炸弹的爆炸半径 如果一个炸弹被引爆时，有其它炸弹在其爆炸半径内， 那么其它炸弹也会爆炸 请问使地图上所有炸弹爆炸所需的最少人为引爆次数。
●	会议室预定
#2022年3月第2周 #线段树 #字节飞书
●	在字节跳动，大家都使用飞书的日历功能进行会议室的预订，遇到会议高峰时期， 会议室就可能不够用，现在请你实现一个算法，判断预订会议时是否有空的会议室可用。 为简化问题，这里忽略会议室的大小，认为所有的会议室都是等价的， 只要空闲就可以容纳任意的会议，并且： 1. 所有的会议预订都是当日预订当日的时段 2. 会议时段是一个左闭右开的时间区间，精确到分钟 3. 每个会议室刚开始都是空闲状态，同一时间一个会议室只能进行一场会议 4. 会议一旦预订成功就会按时进行 ``` 比如上午11点到中午12点的会议即[660, 720) 给定一个会议室总数m 一个预定事件由[a,b,c]代表 :  a代表预定动作的发生时间，早来早得; b代表会议的召开时间; c代表会议的结束时间 给定一个n*3的二维数组，即可表示所有预定事件`````` 返回一个长度为n的boolean类型的数组，表示每一个预定时间是否成功
●	字符串子串包含
#2022年3月第2周 #窗口 #字节飞书
●	小歪每次会给你两个字符串： 笔记s1和关键词s2，请你写一个函数 判断s2的排列之一是否是s1的子串 如果是，返回true 否则，返回false
●	单词补全
#2022年3月第2周 #前缀树 #字节飞书
●	语法补全功能，比如"as soon as possible" 当我们识别到"as soon as"时, 基本即可判定用户需要键入"possible" 设计一个统计词频的模型，用于这个功能 类似(prefix, next word)这样的二元组 比如一个上面的句子"as soon as possible" 有产生如下的二元组(as, soon, 1)、(as soon, as, 1)、(as soon as, possible, 1) 意思是这一个句子产生了如下的统计： 当前缀为"as"，接下来的单词是"soon"，有了1个期望点 当前缀为"as soon"，接下来的单词是"as"，有了1个期望点 当前缀为"as soon as"，接下来的单词是"possible"，有了1个期望点 那么如果给你很多的句子，当然就可以产生很多的期望点，同一个前缀下，同一个next word的期望点可以累加 现在给你n个句子，让你来建立统计 然后给你m个句子，作为查询 最后给你k，表示每个句子作为前缀的情况下，词频排在前k名的联想 返回m个结果，每个结果最多k个单词
●	一致的信号数组
#2022年3月第2周 #前缀树 #字节飞书
●	假设数组a和数组b为两组信号 ``` 1) length(b) <= length(a) 那么就称信号b和信号a一致，记为b==a那么就称信号b和信号a一致，记为b==a那么就称信号b和信号a一致，记为b==a ```给你好多b数组，假设有m个: b0数组、b1数组...给你好多b数组，假设有m个: b0数组、b1数组...给你好多a数组，假设有n个: a0数组、a1数组...给你好多a数组，假设有n个: a0数组、a1数组... 返回一个长度为m的结果数组ans，ans[i]表示 : bi数组和多少个a数组一致
●	M 整除数对
#2022年3月第2周 #微软
●	给定一个数组arr，给定一个正数M 如果arr[i] + arr[j]可以被M整除，并且i < j，那么(i,j)叫做一个M整除对 返回arr中M整除对的总数量
●	完成任务的最少天数
#2022年3月第2周 #窗口最大值和最小值的更新结构
●	给定一个正数数组arr，长度为N，依次代表N个任务的难度，给定一个正数k 你只能从0任务开始，依次处理到N-1号任务结束，就是一定要从左往右处理任务 只不过，难度差距绝对值不超过k的任务，可以在一天之内都完成 返回完成所有任务的最少天数
●	接受服务的最早时间
#2022年3月第2周 #小根堆 #优先队列 #二分
●	给定一个数组arr，长度为n 表示n个服务员，每个人服务一个人的时间 给定一个正数m，表示有m个人等位 如果你是刚来的人，请问你需要等多久？ 假设：m远远大于n，比如n<=1000, m <= 10^9，该怎么做？
●	236.二叉树的最近公共祖先-时间O(N)空间O(1)解法
#2022年3月第2周 #Morris遍历 #最近公共祖先
●	差值大于1的子序列
#2022年3月第3周  #美团
●	给定一个数组arr，你可以随意挑选其中的数字   但是你挑选的数中，任何两个数a和b，必须Math.abs(a - b) > 1   返回你最多能挑选几个数
●	切豆腐
#2022年3月第3周  #美团
●	有一块10000 * 10000 * 10000的立方体豆腐 豆腐的前左下角放在(0,0,0)点，豆腐的后右上角放在(10000,10000,10000)点 下面给出切法的数据结构 [a,b] a = 1，表示x = b处，一把无穷大的刀平行于yz面贯穿豆腐切过去 a = 2，表示y = b处，一把无穷大的刀平行于xz面贯穿豆腐切过去 a = 3，表示z = b处，一把无穷大的刀平行于xy面贯穿豆腐切过去 a = 1 or 2 or 3，0<=b<=10000 给定一个n*2的二维数组，表示切了n刀 返回豆腐中最大的一块体积是多少
●	翻转后的最大子数组和
#2022年3月第3周  #美团  #字节
●	最大子段和是 一个经典问题，即对于一个数组找出其和最大的子数组。 现在允许你在求解该问题之前翻转这个数組的连续一段 如翻转(1,2,3,4,5,6)的第三个到第五个元素組成的子数组得到的是(1,2,5,4,3,6)， 则翻转后该数组的最大子段和最大能达到多少？
●	几乎一样的题，来自字节笔试第4题 给定两个数組values和numbers， values[i]表示i号宝石的单品价值 numbers[i]表示i号宝石的数量 i号宝石的总价值 = values[i] * numbers[i] 如果有一种魔法，可以翻转任何区间L...R的宝石，也就是改变L..R的宝石排列，逆序的求在允许用一次魔法的情况下，任取一段连续区间，能达到的最大价值这两个问法解法都几乎一样，区别无非是:美团的: 可进行一次翻转情况下，子数组最大累加和字节的: 可进行一次翻转情况下，子数组最大价值和
●	重排数组后查询的最大累加和
#2022年3月第3周  #美团 #线段树
●	void add(int L, int R, int C)代表在arr[L...R]上每个数加C int get(int L, int R)代表查询arr[L...R]上的累加和 假设你可以在所有操作开始之前，重新排列arr 请返回每一次get查询的结果都加在一起最大能是多少 输入参数: int[] arr : 原始数组 int[][] ops，二维数组每一行解释如下: [a,b,c]，如果数组有3个数，表示调用add(a,b,c) [a,b]，如果数组有2个数，表示调用get(a,b) a和b表示arr范围，范围假设从1开始，不从0开始 输出： 假设你可以在开始时重新排列arr，返回所有get操作返回值累计和最大是多少
●	大鱼吃小鱼
#2022年3月第3周  #Bilibili
●	现在有N条鱼，每条鱼的体积为Ai，从左到右排列，数组arr给出 每一轮，左边的大鱼一定会吃掉右边比自己小的第一条鱼， 并且每条鱼吃比自己小的鱼的事件是同时发生的。 返回多少轮之后，鱼的数量会稳定 注意：6 6 3 3 第一轮过后 :  对于两个6来说，右边比自己小的第一条鱼都是第1个3，所以只有这个3被吃掉， 数组成 : 6 6 3（第2个3） 第二轮过后 : 6 6 返回2
●	理财产品
#2022年3月第3周  #银联
●	某公司计划推出一批投资项目。 product[i] = price 表示第 i 个理财项目的投资金额 price 。客户在按需投资时，需要遵循以下规则： 客户在首次对项目 product[i] 投资时，需要投入金额 price 对已完成首次投资的项目 product[i] 可继续追加投入，但追加投入的金额需小于上一次对该项目的投入(追加投入为大于 0 的整数) 为控制市场稳定，每人交易次数不得大于 limit。(首次投资和追加投入均记作 1 次交易) 若对所有理财项目中最多进行 limit 次交易，使得投入金额总和最大，请返回这个最大值的总和。  注意： 答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1 示例 1： 输入：product = [4,5,3], limit = 8 输出：26 解释：满足条件的一种情况为： 第一个理财项目进行金额为 4，3，2 的交易； 第二个理财项目进行金额为 5，4，3 的交易； 第三个理财项目进行金额为 3，2 的交易； 得到最大投入金额总和为 5 + 4 * 2 + 3 * 3 + 2 * 2 = 26。 示例 2： 输入：product = [2,1,3], limit = 20 输出：10 解释：可交易总次数小于 limit，因此进行所有交易 第一个理财项目可交易 2 次，交易的金额分别为 2，1； 第二个理财项目可交易 1 次，交易的金额分别为 1； 第三个理财项目可交易 3 次，交易的金额分别为 3，2，1； 因此所得最大投入金额总和为 3 + 2 * 2 + 1 * 3 = 10。 提示： 1 <= product.length <= 10^5 1 <= product[i] <= 10^7 1 <= limit <= 10^9
●	合作开发
#2022年3月第3周  #银联
●	为了不断提高用户使用的体验，开发团队正在对产品进行全方位的开发和优化。   已知开发团队共有若干名成员，skills[i] 表示第 i 名开发人员掌握技能列表。如果两名成员各自拥有至少一门对方未拥有的技能，则这两名成员可以「合作开发」。   请返回当前有多少对开发成员满足「合作开发」的条件。由于答案可能很大，请你返回答案对 10^9 + 7 取余的结果。 注意： -   对于任意 skills[i] 均升序排列。 示例 1： 输入：   skills = [[1,2,3],[3],[2,4]]   输出: 2   解释：    开发成员 [1,2,3] 和成员 [2,4] 满足「合作开发」的条件，技能 1 和 4 分别是对方未拥有的技术    开发成员 [3] 和成员 [2,4] 满足「合作开发」的条件，技能 3 和 4 分别是对方未拥有的技术    开发成员 [1,2,3] 和成员 [3] 不满足「合作开发」的条件，由于开发成员 [3] 没有对方未拥有的技术    因此有 2 对开发成员满足「合作开发」的条件。 示例 2：  输入：    skills = [[3],[6]]    输出: 1   解释：    开发成员 [3] 和成员 [6] 满足「合作开发」的条件    因此有 1 对开发成员满足「合作开发」的条件。 提示： -   2 <= skills.length <= 10^5 -   1 <= skills[i].length <= 4 -   1 <= skills[i][j] <= 1000 -   skills[i] 中不包含重复元素
